[{"path":"https://mflores72000.github.io/qcr/articles/CAP.html","id":"asumiendo-una-distribución-normal","dir":"Articles","previous_headings":"","what":"Asumiendo una distribución normal","title":"Análisis de capacidad de un proceso","text":"Los índices de capacidad más utilizados en la industria, analizan la capacidad del proceso bajo la suposición de que el proceso es estable y de que la característica estudiada se distribuye normalmente. En la Table~ se describen los índices \\(C_p,C_{pk},C_{pm},C_{pmk}\\) que se obtienen partir de estos supuestos. Kerstin Vannman (1995) propone una formulación general de estos índices mediante una expresión que permite obtenerlos para distintos valores de dos nuevos parámetros negativos \\(u\\) y \\(v\\): \\[ C_p\\left( u,v\\right)= \\frac{d-u\\vert \\mu - m\\vert}{3\\sqrt{\\sigma^2+v\\left( \\mu - T\\right)^2}}\\] Esta nueva expresión permite obtener los índices de Table~, sin más que considerar valores de 0 y 1 para \\(u\\) y \\(v\\): \\(C_p\\left( 0, 0\\right) = C_p\\), \\(C_p\\left( 1, 0\\right) = C_{pk}\\), \\(C_p\\left( 0, 1\\right) = C_{pm}\\), \\(C_p\\left( 1, 1\\right) = C_{pmk}\\).","code":"data(pistonrings)  xbar <- qcs.xbar(pistonrings[1:125,],plot = TRUE) mu <-xbar$center std.dev <-xbar$std.dev LSL=73.99; USL=74.01 qcs.cp(parameters = c(0,0),limits = c(LSL,USL),        mu = mu,std.dev = std.dev,ylim=c(0,1), contour = FALSE) #>     Cp  delta  gamma  #> 0.3407 0.1176 0.9785 qcs.cp(object = xbar,parameters = c(0,0), limits = c(LSL,USL),ylim=c(0,1), contour = FALSE) #>     Cp  delta  gamma  #> 0.3407 0.1176 0.9785 qcs.cp(object = xbar,parameters = c(1,0), limits = c(LSL,USL),ylim=c(0,1), contour = FALSE) #>    Cpk  delta  gamma  #> 0.3006 0.1176 0.9785 qcs.cp(object = xbar,parameters = c(0,1), limits = c(LSL,USL),ylim=c(0,1), contour = FALSE) #>    Cpm  delta  gamma  #> 0.3382 0.1176 0.9785 qcs.cp(object = xbar,parameters = c(1,1), limits = c(LSL,USL),ylim=c(0,1), contour = FALSE) #>   Cpmk  delta  gamma  #> 0.2984 0.1176 0.9785"},{"path":"https://mflores72000.github.io/qcr/articles/CAP.html","id":"gráfico-de-la-capacidad-del-proceso","dir":"Articles","previous_headings":"Asumiendo una distribución normal","what":"Gráfico de la capacidad del proceso","title":"Análisis de capacidad de un proceso","text":"Deleryd y Vannman (1999) y Vannman (2001), (2006) propusieron un método gráfico basado en los índices de capacidad para analizar la capacidad de un proceso. La ventaja de usar este tipo de gráficos, comparado con utilizar sólo el índice de capacidad, es que los gráficos proporcionan información visual instantáneamente: información sobre la localización y variación de la característica estudiada del proceso e información sobre la capacidad del proceso. Un proceso se dice que es capaz si el índice de capacidad del proceso excede un cierto valor k, donde k > 1. Algunos de los valores de k que más se usan son k = 1, k = 4/3, o k = 5/3. Se supondrá que el valor del target coincide con el centro del intervalo de especificación, es decir, \\(T = \\frac{\\left( USL + LSL\\right)}{2} = m\\). Entonces, se utilizará uno de los índices definidos por la familia \\(C_p\\left( u,v\\right)\\) por ejemplo, \\(C_{pk}\\) o \\(C_{pm}\\) y se definirá el proceso como capaz si \\(C_p\\left( u, v\\right) > k\\), dados los valores de u, v, y k. Notemos de nuevo que si \\(\\mu = T\\), todos los índices \\(C_p\\left( u, v\\right)\\), se reducen al mismo,\\(C_p\\). Diferentes elecciones de u, v, y k imponen diferentes restricciones en los parámetros del proceso \\(\\left( \\mu, \\sigma \\right)\\). Esto se puede ver f´acilmente en un gr´afico de capacidades. Este gráfico es simplemente un gráfico de contorno de \\(C_p\\left( u, v\\right) = k\\) como una función de \\(\\mu\\) y \\(\\sigma\\), o como una función de \\(\\delta\\) y \\(\\gamma\\), donde \\(\\delta = \\frac{\\mu - T}{d}\\) y \\(\\gamma = \\frac{\\sigma}{d}\\). La línea de contorno se obtiene reescribiento el índice \\(C_p\\left( u,v\\right)\\) como una función de \\(\\delta\\) y \\(\\gamma\\), resolviendo la ecuación \\(C_p\\left( u,v\\right) = k\\) con respecto \\(\\gamma\\), y graficando \\(\\gamma\\) como una función de \\(delta\\). Se obtiene: \\[ \\gamma = \\sqrt{\\frac{\\left( 1-u\\vert\\delta\\vert\\right)}{9k^2}-v\\delta^2}, \\; \\vert\\delta\\vert \\leq \\frac{1}{u+3k\\sqrt{v}}, \\; \\left( u,v\\right) \\neq \\left(0,0 \\right). \\] Cuando \\(u = v = 0\\), es decir, cuando consideramos el índice \\(C_p = k\\), tenemos \\(\\gamma = \\frac{1}{3k}, \\; \\vert\\delta\\vert \\leq 1\\). Valores de los parámetros \\(\\mu\\) y \\(\\sigma\\) que proporcionen valores \\(\\left( \\delta,\\gamma\\right)\\) dentro de la región acotada por la línea de contorno \\(C_p\\left(u, v\\right) = k\\) y el eje \\(\\delta\\) proporcionarán un valor \\(C_p\\left(u, v\\right)\\) más grande que k, es decir, un proceso capaz. Además valores de \\(\\mu\\) y \\(\\sigma\\) que proporcionen valores \\(\\left( \\delta,\\gamma\\right)\\) fuera de esta región proporcionarán un valor \\(C_p\\left(u, v\\right)\\) más pequeño que k, es decir, un proceso capaz. En el caso que el proceso es capaz, este tipo de gráfico es muy útil para entender si es la variabilidad, la desviación del target o ambas cosas las que se necesitan reducir para mejorar la capacidad.","code":"data(pistonrings)  xbar <- qcs.xbar(pistonrings[1:125,],plot = TRUE) mu <-xbar$center std.dev <-xbar$std.dev LSL=73.99; USL=74.01 qcs.cp(parameters = c(0,0),limits = c(LSL,USL),        mu = mu,std.dev = std.dev,ylim=c(0,1)) #>     Cp  delta  gamma  #> 0.3407 0.1176 0.9785 qcs.cp(object = xbar,parameters = c(0,0), limits = c(LSL,USL),ylim=c(0,1)) #>     Cp  delta  gamma  #> 0.3407 0.1176 0.9785 qcs.cp(object = xbar,parameters = c(1,0), limits = c(LSL,USL),ylim=c(0,1)) #>    Cpk  delta  gamma  #> 0.3006 0.1176 0.9785 qcs.cp(object = xbar,parameters = c(0,1), limits = c(LSL,USL),ylim=c(0,1)) #>    Cpm  delta  gamma  #> 0.3382 0.1176 0.9785 qcs.cp(object = xbar,parameters = c(1,1), limits = c(LSL,USL),ylim=c(0,1)) #>   Cpmk  delta  gamma  #> 0.2984 0.1176 0.9785"},{"path":"https://mflores72000.github.io/qcr/articles/CAP.html","id":"gráfico-de-la-capacidad-del-proceso-estimado","dir":"Articles","previous_headings":"Asumiendo una distribución normal","what":"Gráfico de la capacidad del proceso estimado","title":"Análisis de capacidad de un proceso","text":"En la práctica los parámetros del proceso son desconocidos y necesitamos estimarlos. Podemos establecer entonces, una regla de decisión basada en los estadísticos muestrales y un gráfico de capacidad del proceso estimado, para usarla para decidir si un proceso se puede considerar capaz o , cuando \\(\\mu\\) y \\(\\sigma\\) son desconocidas y necesitamos estimarlas por: \\[\\hat{\\mu}=\\bar{x}=\\frac{1}{n}\\sum_{=1}^n{X_i} \\; y \\;  \\hat{\\sigma}^2=\\frac{1}{n}\\sum_{=1}^n{X_i-\\bar{X}}\\] que son los estimadores de máxima verosimilitud en el caso en el que la característica estudiada del proceso se distribuye normalmente; y sea \\(X_1,X_2,\\dots,X_n\\) una muestra aleatoria simple de una distribución normal con media \\(\\mu\\) y varianza \\(\\sigma^2\\). En el paquete sólo se usa el índice \\(C_{pm}\\) para definir la región de capacidad. Para el caso general, ver Vannman (2001). Para obtener una regla de decisión apropiada se considerará el test de hipótesis con hipótesis nula \\(H_0 : C_{pm} \\leq k_0\\) e hipótesis alternativa \\(H_1 : C_{pm} > k_0\\). Como estadístico de contraste se utiliza el estimador \\(\\hat{C_{pm}}\\), el cual se obtiene estimando \\(\\mu\\) y \\(\\sigma\\) La hipótesis nula se rechazará si \\(\\hat{C}_{pm} > c_{\\alpha}\\), donde la constante \\(c_{\\alpha}\\) está determinada de modo que el nivel de significación del test sea \\(\\alpha\\). Vannman (2001) demostró que la hipótesis nula \\(H_0 : C_{pm} \\leq k_0\\) puede reducirse \\(H_0 : C_{pm} = k_0\\). La regla de decisión que se usa consiste en que, para valores dados de \\(\\alpha\\) y n, el proceso se considerará capaz si \\(\\hat{C}_{pm} > c_{\\alpha}\\), donde \\(c_{\\alpha} > k_0\\). Hubele y Vannman (2004) demostraron que, cuando se usa el índice \\(C_{pm}\\) el valor crítico para un nivel de significación \\(\\alpha\\) se obtiene como \\(c_{\\alpha}=k_0\\sqrt{\\frac{n}{\\chi^2_{\\alpha,n}}}\\), donde \\(\\chi^2_{\\alpha,n}\\) es el cuantil \\(\\alpha\\) de una distibución \\(\\chi^2\\) con n grados de libertad.","code":"data(pistonrings)  xbar <- qcs.xbar(pistonrings[1:125,],plot = TRUE) mu <-xbar$center std.dev <-xbar$std.dev LSL=73.99; USL=74.01 qcs.hat.cpm(limits = c(LSL,USL),             mu = mu,std.dev = std.dev,ylim=c(0,1)) qcs.hat.cpm(object = xbar, limits = c(LSL,USL),ylim=c(0,1))"},{"path":"https://mflores72000.github.io/qcr/articles/CAP.html","id":"non-normal-parametric-process-capability-analysis","dir":"Articles","previous_headings":"","what":"Non Normal parametric process capability analysis","title":"Análisis de capacidad de un proceso","text":"En el documento correspondiente ISO 21747 (2006), se definen los siguientes índices:","code":"data(pistonrings)  xbar <- qcs.xbar(pistonrings[1:125,],plot = TRUE) limits = c(lsl = 73.99, usl = 74.01) qcs.pcr(xbar, \"normal\", limits = limits) #>  #> Process Capability Analysis #>  #> Call: #> qcs.pcr(object = xbar, distribution = \"normal\", limits = limits) #>  #> Number of obs = 125          Target = 74 #>        Center =  74               LSL =  73.99 #>        StdDev =  0.009785         USL =  74.01 #>  #> Capability indices: #>  #>        Value #> Cp    0.3407 #> Cp_l  0.3807 #> Cp_u  0.3006 #> Cp_k  0.3006 #>  #>  #> PPM: #>  #>          Exp<LSL 1.267e+05       Obs<LSL 0 #>          Exp>USL 1.836e+05       Obs>USL 1e+12 #>        Exp Total 3.103e+05     Obs Total 1e+12 #>  #> Test: #>  #>  #>  Anderson Darling Test for normal distribution #>  #> data:  x  #> A = 0.1399, mean = 74.001, sd = 0.005, p-value = 0.9694 #> alternative hypothesis: true distribution is not equal to normal qcs.pcr(xbar, \"weibull\", limits = limits) #>  #> Process Capability Analysis #>  #> Call: #> qcs.pcr(object = xbar, distribution = \"weibull\", limits = limits) #>  #> Number of obs = 125          Target = 74 #>        Center =  74               LSL =  73.99 #>        StdDev =  0.009785         USL =  74.01 #>  #> Capability indices: #>  #>        Value #> Cp    0.5801 #> Cp_l  0.4861 #> Cp_u  0.8402 #> Cp_k  0.4861 #>  #>  #> PPM: #>  #>          Exp<LSL 3.283e+04       Obs<LSL 0 #>          Exp>USL 9965            Obs>USL 1e+12 #>        Exp Total 4.279e+04     Obs Total 1e+12 #>  #> Test: #>  #>  #>  Anderson Darling Test for weibull distribution #>  #> data:  x  #> A = 0.7297, shape = 18232.755, scale = 74.004, p-value <= 0.05 #> alternative hypothesis: true distribution is not equal to weibull"},{"path":"https://mflores72000.github.io/qcr/articles/CAP.html","id":"análisis-de-capacidad-no-paramétrico","dir":"Articles","previous_headings":"","what":"Análisis de capacidad no paramétrico","title":"Análisis de capacidad de un proceso","text":"Las hipótesis tradicionales sobre los datos como la normalidad o la independencia son frecuentemente violadas en muchas situaciones reales. Así, en escenarios en los que los supuestos de normalidad se verifican, los índices definidos en las secciones anteriores son válidos. Pearn y Chen (1997) y Tong y Chen (1998) propusieron generalizaciones de \\(C_p\\left(u, v\\right)\\) para el caso de distribuciones arbitrarias de los datos: \\[ C_{Np}\\left( u,v\\right)= \\frac{d-u\\vert M - m\\vert}{3\\sqrt{\\left(\\frac{F_{99.865}-F_{0.135}}{6} \\right)^2+v\\left( M - T\\right)^2}}\\] donde \\(F_{\\alpha}\\) el correspondiente percentil (100 \\(\\alpha\\))% de la distribución y M la mediana del proceso. Pearn y Chen, propusieron el siguiente estimador: \\[ \\hat{C}_{Np}\\left( u,v\\right)= \\frac{d-u\\vert \\hat{M} - m\\vert}{3\\sqrt{\\left(\\frac{U_p-L_p}{6} \\right)^2+v\\left( \\hat{M} - T\\right)^2}}\\] donde \\(U_p\\) es un estimador para \\(F_{99.865}\\), \\(L_p\\) es un estimador para \\(F_{99.865}\\) y \\(\\hat{M}\\) es un estimador para M, y sus estimaciones se pueden obtener utilizando las tablas desarrolladas por Gruska et al. (1989). Sin embargo la distribución del proceso subyacente es siempre desconocida. Chang y Lu (1994) calcularon estimaciones para \\(F_{99.865}\\), \\(F_{99.865}\\) y M basándose en los percentiles muestrales en vez de en las tablas de Gruska et al. (1989). Se tiene así el estimador: \\[ \\hat{C}_{Np}\\left( u,v\\right)= \\frac{d-u\\vert \\hat{M} - m\\vert}{3\\sqrt{\\left(\\frac{\\hat{F}_{99.865}-\\hat{F}_{0.135}}{6} \\right)^2+v\\left( \\hat{M} - T\\right)^2}}\\]","code":"xbar <- qcs.xbar(pistonrings[1:125,],plot = TRUE) x<-xbar$statistics[[1]] LSL=73.99; USL=74.01 median <-median(x) lq=as.numeric(quantile(x,probs=0.00135)) uq=as.numeric(quantile(x,probs=0.99865)) qcs.cpn(parameters = c(0,0),limits = c(LSL,USL),         median = median, q=c(lq,uq)) #>    CNp  #> 1.0082 qcs.cpn(object = xbar,parameters = c(0,0), limits = c(LSL,USL)) #>    CNp  #> 1.0082 qcs.cpn(object = xbar,parameters = c(1,0), limits = c(LSL,USL)) #>   CNpk  #> 0.9275 qcs.cpn(object = xbar,parameters = c(0,1), limits = c(LSL,USL)) #>   CNpm  #> 0.9799 qcs.cpn(object = xbar,parameters = c(1,1), limits = c(LSL,USL)) #>  CNpmk  #> 0.9015"},{"path":"https://mflores72000.github.io/qcr/articles/CAP.html","id":"un-análisis-completo-del-proceso","dir":"Articles","previous_headings":"","what":"Un análisis completo del proceso","title":"Análisis de capacidad de un proceso","text":"","code":"data(pistonrings)  xbar <- qcs.xbar(pistonrings[1:125,],plot = TRUE) LSL=73.99; USL=74.01 limits = c(lsl = 73.99, usl = 74.01) qcs.ca(xbar, limits = limits) #>  #> Process Capability Analysis #>  #> Call: #> qcs.ca(object = xbar, limits = limits) #>  #> Number of obs = 125          Target = 74 #>        Center =  74               LSL =  73.99 #>        StdDev =  0.009785         USL =  74.01 #>  #> Paremetric Capability indices: #>  #>        Value    0.1%   99.9% #> Cp    0.3407  0.2771  0.4065 #> Cp_l  0.3807  0.2739  0.4875 #> Cp_u  0.3006  0.2021  0.3991 #> Cp_k  0.3006  0.1944  0.4068 #> Cpm   0.3382  0.2749  0.4038 #>  #>  #> Non parametric Capability indices: #>  #>         Value #> CNp    1.0082 #> CNpK   0.9275 #> CNpm   0.9799 #> CNpmk  0.9015 #>  #>  #> PPM: #>  #>          Exp<LSL 1.267e+07       Obs<LSL 0 #>          Exp>USL 1.836e+07       Obs>USL 8e+05 #>        Exp Total 3.103e+07     Obs Total 8e+05 #>  #> Test: #>  #>  #>  Anderson Darling Test for normal distribution #>  #> data:  xbar  #> A = 0.1399, mean = 74.001, sd = 0.005, p-value = 0.9694 #> alternative hypothesis: true distribution is not equal to normal"},{"path":"https://mflores72000.github.io/qcr/articles/Mqcc.html","id":"hotelling","dir":"Articles","previous_headings":"","what":"Hotelling","title":"Gráficos de Control de la calidad Multivariante","text":"Consideremos un proceso de control en el que se observan \\(p\\) variables que se distribuyen segúnn una Normal \\(p\\) variante con un vector de medias \\(\\mu_0=\\left(\\mu_{01},\\mu_{02},\\dots,\\mu_{0p}\\right)\\) y una matriz \\(\\Sigma_0\\) de varianzas-covarianzas de orden \\(p\\) denotada por \\(N_p\\left(\\mu_0,\\Sigma_0\\right)\\). Se desea contrastar las hipótesis: \\(H_0: \\mu_i = \\mu_0\\) vs. \\(H_1: \\mu_i \\ne \\mu_0\\) para determinar si el proceso está bajo control. Para esto se diseñan criterios para determinar si el proceso esta fuera de control que utilizan el estadístico \\(T^2\\) de Hotelling que dependiendo del estado de proceso sigue una determinada distribución. Cuando el proceso está bajo control, (\\(\\mu_i = \\mu_0\\)), existe una probabilidad \\(\\alpha\\) de que el estadístico \\(T^2_i\\) exceda al valor crítico \\(\\mathcal{X}^2_{p,\\alpha}\\). Por ello se toma como indicación o señal de fuera de control un valor del estadístico \\(T^2_i\\) que supera al valor \\(\\mathcal{X}^2_{p,\\alpha}\\). El estadístico \\(T^2\\) Hotelling es: \\[T^2_i=n\\left( \\bar{X}_i-\\mu_0\\right)^t \\Sigma_0^{-1}\\left( \\bar{X}_i-\\mu_0\\right)\\] donde \\(\\bar{X}_i=\\left( \\bar{X}_{i1},\\dots,\\bar{X}_{ip}\\right)\\) es el vector de medias para las \\(p-\\)características, en la \\(-\\)ésima muestra. Cuando el tamaño del subgrupo \\(n = 1\\), se obtendrán vectores de observaciones en lugar de vectores de medias. En el contexto geométrico, el estadístico \\(T^2\\) es una proporción de la distancia (Mahalanobis) al cuadrado entre una observación multivariada y el vector de valores objetivo (vector de media), donde puntos equidistantes forman elipsoides alrededor de dicho vector. mayor valor de \\(T^2\\), mayor es la distancia entre la observación y el valor objetivo. Si \\(\\mu_0\\) y \\(\\Sigma_0\\) son conocidos y el proceso está bajo control, el estadístico \\(T^2_i\\) se distribuye como una chi-cuadrado central con \\(p\\) grados de libertad (\\(T^2_i\\approx \\mathcal{X}^2_p\\)). Cuando el proceso está bajo control, el estadístico \\(T^2_i\\) se distribuye como una variable chi- cuadrado central con \\(p\\) grados de libertad y con parámetro de centralidad: \\(\\lambda = n\\left( \\mu_1-\\mu_0\\right)^t \\Sigma_0^{-1}\\left( \\mu_1-\\mu_0\\right)\\), con \\(\\mu_1 \\ne \\mu_0\\); donde \\(\\mu_1\\) es el vector de medias de las \\(p\\) características, cuando existe un cambio \\(d\\) en al menos una de las medias. En la práctica, el valor del estadístico \\(T^2\\) se estima mediante los correspondientes valores muestrales, dando como resultado la siguiente expresión: \\[ T^2=n\\left( \\bar{X}-\\bar{\\bar{X}}\\right)^t S^{-1}\\left( \\bar{X}-\\bar{\\bar{X}}\\right)\\] Con distribución bajo la hipótesis nula: \\[T^2 \\approx \\frac{p\\left( m-1\\right) \\left(n-1 \\right) }{mn-m-p+1}F_{\\alpha,p,mn-m-p+1}\\] Es decir, el estadístico \\(T^2\\) sigue apróximadamente en este caso una \\(F\\) de Snedecor con \\(p\\) y \\(\\left( mn-m-p+1\\right)\\) grados de libertad, para un nivel de significación del \\(\\alpha \\%\\). Dado que tanto la distribución \\(\\mathcal{X}^2\\) y la \\(F\\) son asimétricas con sesgo la derecha, se considera únicamente la expresión para el límite de control superior, que viene dada por: \\[LCS=\\frac{p\\left( m-1\\right) \\left(n-1 \\right) }{mn-m-p+1}F_{\\alpha,p,mn-m-p+1}\\] Para el límite inferior se considera \\(LCI=0\\) Además, para procesos en los que el \\(m\\) es suficientemente grande, \\(m>100\\), se puede aproximar este límite por \\(LCS=\\textit{X}^2_{\\alpha,p}\\). Alt (1985) recomienda usar estos límites en una primera fase, lo que denomina análisis retrospectivo, para una vez estimado el límite de control por este medio, calcular un segundo límite para la segunda fase, la de monotorización del proceso, para ello propone un cambio consistente en multiplicar por la expresión \\(\\frac{m+1}{m-1}\\) obteniendo así una nueva expresión para el límite de control superior LCS. En el caso de observaciones individuales, es decir \\(n=1\\), suponiendo que se tienen un total de \\(m\\) muestras, para evaluar \\(p\\) variables de control, el correspondiente gráfico de control se construye mediante: \\[LCS=\\frac{p\\left( m+1\\right) \\left(n-1 \\right) }{m^2-mp}F_{\\alpha,p,m-p}\\] \\[LCI=0\\]","code":"data(dowel1) str(dowel1) #> 'data.frame':    40 obs. of  2 variables: #>  $ diameter: num  0.492 0.501 0.491 0.492 0.505 0.5 0.497 0.509 0.49 0.499 ... #>  $ length  : num  0.988 1.011 1.008 0.97 1.003 ... data.mqcd <- mqcd(dowel1) res.mqcs <- mqcs.t2(data.mqcd) summary(res.mqcs) #>  #> Summary of group statistics: #>        V1          #>  Min.   :0.09137   #>  1st Qu.:0.60154   #>  Median :1.66096   #>  Mean   :1.95000   #>  3rd Qu.:2.64402   #>  Max.   :5.34020   #>  #> Number of quality characteristics:  2 #> Number of samples or observations:  40 #> Number of observations or sample size:  1 #>  #> Mean Vector:  #>  0.500875 1.001825 #> Covariance Matrix: #>          diameter       length #> [1,] 4.908654e-05 8.584936e-05 #> [2,] 8.584936e-05 4.199429e-04 #>  #> Control limits:  #>      lcl      ucl  #>  0.00000 12.44888  #>  #> Number beyond limits: 0 plot(res.mqcs, title =\" Hotelling Control Chart for dowel1\")"},{"path":"https://mflores72000.github.io/qcr/articles/Mqcc.html","id":"gráficos-mcusum","dir":"Articles","previous_headings":"","what":"Gráficos MCUSUM","title":"Gráficos de Control de la calidad Multivariante","text":"Los gráficos CUSUM pueden extenderse también al caso multivariante, aunque hay una única forma de hacerlo. Los primeros en realizar estudios en la materia fueron Woodall y Ncube (1985), usando un esquema basado en múltiples (\\(p\\)) CUSUM univariantes. Healy (1987) desarrolló un modelo de gráfico CUSUM multivariante mediante: \\[G_i=max\\left\\lbrace \\left( G_{-1}+^t\\left( x_i-\\mu_0\\right)-0,5\\lambda\\mu_1 \\right),0 \\right\\rbrace \\] Donde: \\(\\mu_0\\): Vector de medias cuando el proceso está bajo control \\(\\Sigma_0\\): Matriz de varianzas-covarianzas bajo control \\(\\mu_1\\): Vector de medias cuando el proceso est’bajo control \\(\\lambda\\mu_1\\): Ra’iz cuadrada del par’ametro de descentrado \\(^t=\\frac{}{\\lambda\\mu_1}\\), \\(=\\left(\\mu_1-\\mu_0\\right)^t\\Sigma_0^{-1}\\) Para interpretar el gráfico se considera que se produce una señal de alarma cuando \\(G_i\\) supera un cierto valor de referencia \\(H\\), convenientemente elegido y que se encuentra tabulado. Hawkins (1991) desarrolla un modelo para variables ajustadas mediante regresión multivariante, en base la suposición de que cuando se produce un cambio en la media, se produce de una determinada manera. Concretamente se asume que el cambio se debe una variación de magnitud \\(d\\) en la media de una de las variables. Otras propuesta de gráficos MCUSUM son los de Croisier (1988) o los de Pignatiello y Runger (1990). En el paquete qcr se ha implementado el procedimiento de Croisier que reduce cada observación multivariada un escalar y luego construye el estadístico CUSUM con los escalares. Croisier considera el siguiente estadístico: \\(T_i=\\sqrt{T^2_i}=\\sqrt{n\\left( \\bar{X}_i-\\mu_0\\right)^t \\Sigma_0^{-1}\\left( \\bar{X}_i-\\mu_0\\right)}\\) Crosier considera el estadístico \\(T\\) porque de esa manera, se acumulan distancias en lugar de distancias al cuadrado. El estadístico MCUSUM se calcula de la siguiente manera: %\\[ S_i=max\\left\\lbrace0,S_{-1}+T_i-k \\right\\rbrace \\] donde \\(S_0\\ge 0\\) (en general se considera \\(S_0=0\\)) y \\(k>0\\). El gráfico MCUSUM da una señal de fuera de control cuando el valor de \\(S_i\\) es mayor que un cierto valor \\(h\\) que depende del valor del \\(ARL\\) deseado cuando el proceso está funcionando en el valor objetivo \\(\\left[ S_i > h \\right]\\). Para determinar los valores de h y k para \\(p = 2, 5,10\\) y \\(20\\) y para valores de \\(ARL\\) de \\(200\\) y de \\(500\\) cuando el proceso está bajo control Crosier empleo procesos de Markov. Estas tablas se diseñaron para detectar un cambio \\(d = 1\\) en el vector de medias, donde \\(d = \\lambda\\) , con \\(\\lambda\\) parámetro de centralidad. En este caso especial los valores de \\(k\\) ’optimos se aproximan \\(p\\).","code":"data(dowel1) str(dowel1) #> 'data.frame':    40 obs. of  2 variables: #>  $ diameter: num  0.492 0.501 0.491 0.492 0.505 0.5 0.497 0.509 0.49 0.499 ... #>  $ length  : num  0.988 1.011 1.008 0.97 1.003 ... data.mqcd <- mqcd(dowel1) res.mqcs <- mqcs.mcusum(data.mqcd) summary(res.mqcs) #>  #> Summary of group statistics: #>        V1         #>  Min.   :0.0000   #>  1st Qu.:0.7749   #>  Median :1.1501   #>  Mean   :1.3818   #>  3rd Qu.:1.9987   #>  Max.   :3.8409   #>  #> Number of quality characteristics:  2 #> Number of samples or observations:  40 #> Number of observations or sample size:  1 #>  #> Mean Vector:  #>  0.500875 1.001825 #> Covariance Matrix: #>          diameter       length #> [1,] 4.908654e-05 8.584936e-05 #> [2,] 8.584936e-05 4.199429e-04 #>  #> Control limits:  #> lcl ucl  #> 0.0 5.5  #>  #> Number beyond limits: 0 plot(res.mqcs, title =\" MCUSUM Control Chart for dowel1\")"},{"path":"https://mflores72000.github.io/qcr/articles/Mqcc.html","id":"gráficos-mewma","dir":"Articles","previous_headings":"","what":"Gráficos MEWMA","title":"Gráficos de Control de la calidad Multivariante","text":"El gráfico de medias móviles ponderadas exponencialmente para el caso multivariante (MEWMA) es una extensión esta nueva situación del correspondiente gráfico univariante. La extensión multivariante, propuesta por Lowry (1992), adopta la forma: \\[Z_i=\\Lambda X_i +\\left( -\\Lambda\\right)Z_{-1}\\] donde: \\(X_i\\) es el vector de medias muestrales y \\(\\Lambda\\) es la matriz diagonal formada por los valores \\(\\lambda\\) para las distintas variables. Los \\(\\lambda_j\\) marcan la profundidad de la memoria para cada variable. mayor valor de \\(r_j\\), menor profundidad. \\(\\) es la matriz identidad y se considera como valor inicial \\(Z_0=0\\). La información que proporcionan los \\(Z_i\\) se recoge en el estadístico: \\[T^2_i=Z_i^t\\Sigma_{Z_i}^{-1}Z_i\\] Donde \\(\\Sigma_{Z_i}^{-1}\\) es la inversa de la matriz de varianzas-covarianzas de los \\(Z_i\\). La señal de salida de control se produce cuando \\(T_i^2\\) supera un cierto valor \\(h\\), (\\(h>0\\)) seleccionado de manera tal de lograr un cierto valor de \\(ARL\\) cuando el proceso está bajo control. Si existe priori ninguna razón para ponderar en forma diferente las observaciones pasadas de cada una de las \\(p\\) variables (como generalmente sucede), entonces se considera \\(\\lambda_1=\\dots=\\lambda_p\\). La matriz \\(\\Sigma_{Z_i}\\) puede obtenerse partir de los elementos de la matriz de varianzascovarianzas correspondiente las variables analizadas mediante la expresi’: \\[\\Sigma_{Z_i}=\\frac{\\lambda}{2-\\lambda}\\left[ 1-\\left( 1-\\lambda\\right)^{2i} \\right]\\Sigma_x \\] donde \\(\\Sigma_x\\) es la matriz de varianzas-covarianzas original. Cuando \\(r=1\\), el gráfico MEWMA coincide con el gráfico de control \\(T^2\\) dado que el valor asintótico de la matriz de varianza-covarianza de \\(Z_i\\) es: \\[\\Sigma_{Z_i}=\\frac{\\lambda}{2-\\lambda}\\Sigma_x \\] En lo que respecta al límite de control (superior) empleado, Runger y Prabhu (1996) sugieren una aproximación mediante cadenas de Markov, que permite estudiar el funcionamiento del gráfico referente al \\(ARL\\). Proporcionan además una serie de recomendaciones para la selección de los par’ametros del gráfico. En lo que se refiere al parámetro \\(\\lambda\\), Montgomery (1991) recomienda que su valor está comprendido entre 0.05 y 0.25. Cuanto mayor sea el valor del parámetro, menor importancia se le estará dando los valores más alejados en el tiempo. En aplicaciones prácticas se elige 0.1 como el valor del parámetro \\(\\lambda\\).","code":"data(dowel1) str(dowel1) #> 'data.frame':    40 obs. of  2 variables: #>  $ diameter: num  0.492 0.501 0.491 0.492 0.505 0.5 0.497 0.509 0.49 0.499 ... #>  $ length  : num  0.988 1.011 1.008 0.97 1.003 ... data.mqcd <- mqcd(dowel1) res.mqcs <- mqcs.mewma(data.mqcd) summary(res.mqcs) #>  #> Summary of group statistics: #>        V1          #>  Min.   :0.04165   #>  1st Qu.:0.95586   #>  Median :1.69276   #>  Mean   :1.62204   #>  3rd Qu.:1.89606   #>  Max.   :4.17595   #>  #> Number of quality characteristics:  2 #> Number of samples or observations:  40 #> Number of observations or sample size:  1 #>  #> Mean Vector:  #>  0.500875 1.001825 #> Covariance Matrix: #>          diameter       length #> [1,] 4.908654e-05 8.584936e-05 #> [2,] 8.584936e-05 4.199429e-04 #>  #> Control limits:  #>    lcl    ucl  #> 0.0000 8.6336  #>  #> Number beyond limits: 0 plot(res.mqcs, title =\" MEWMA Control Chart for dowel1\")"},{"path":"https://mflores72000.github.io/qcr/articles/Npqcc.html","id":"gráficos-de-control-de-la-calidad-no-paramétricos","dir":"Articles","previous_headings":"","what":"Gráficos de control de la calidad no paramétricos","title":"Gráficos de control de la calidad no paramétricos","text":"Los gráficos de control que se presenta en esta sección son propuestas por Regina Liu (Liu, 1995). La idea principal bajo sus gráficos de control es reducir cada medida multivariante un índice univariado, o mejor dicho su ordenamiento relativo del centro hacia afuera inducido por profundidad de datos. Este planteo es completamente paramétrico, y así las cartas resultantes son válidas sin suposiciones paramétricas en el modelo del proceso. Estos gráficos permiten detectar simultáneamente el cambio en localización (desplazamiento de la media) y el incremento de escala (cambio en variabilidad) en un proceso. Liu desarrolló los gráficos de control r, Q y S los cuales pueden ser vistos como generalizaciones multivariadas basadas en profundidad de datos de los gráficos univariadas X, \\(\\bar{x}\\) y Cusum respectivamente.","code":""},{"path":"https://mflores72000.github.io/qcr/articles/Npqcc.html","id":"profundidad-de-datos","dir":"Articles","previous_headings":"Gráficos de control de la calidad no paramétricos","what":"Profundidad de datos","title":"Gráficos de control de la calidad no paramétricos","text":"En el análisis multivariante, el término profundidad se refiere al grado de centralidad de un punto con respecto una nube de puntos o una distribución de probabilidad. Por tanto, es posible definir un orden en el espacio euclídeo multidimensional través de la profunidad de un dato. Según Dyckerhoff ,(Dyckerhoff, 2004) y expuestas por Cascos (Cascos, 2011) la definición de la función de profundidad es: Si se fija una distribución \\(P\\) en \\(R^{d}\\), una función de profundidad es una función acotada \\(D_{p}:R^{d} \\longrightarrow R\\) que asigna cada punto de \\(R^{d}\\) su grado de centralidad respecto de P. Las funciones de profundidad con las que se pueden realizar los gráficos de control son: Profundidad Simplicial (Liu, 1990) Profundidad de Mahalanobis (Mahalanobis 1936) Profundidad Semiespacial (Half-Space) o de Tukey (Hodges, 1955, Tukey, 1975) Profundidad de Verosimilitud (Likelihood Depth), (Fraiman y Meloche, 1996), (Liu, 1999) Profundidad de las Proyecciones (Random Projection Depth) (Zuo y Serfling, 2000) Para el cálculo de las profundidades se utiliza el paquete fda.qcr.","code":""},{"path":"https://mflores72000.github.io/qcr/articles/Npqcc.html","id":"estadísticos-derivados-de-la-profundidad-de-datos","dir":"Articles","previous_headings":"Gráficos de control de la calidad no paramétricos > Profundidad de datos","what":"Estadísticos derivados de la profundidad de datos","title":"Gráficos de control de la calidad no paramétricos","text":"Sea \\(G\\) la distribución \\(k-\\)dimensional y \\(Y_1,Y_2,\\ldots,Y_m\\); m observaciones aleatorias de \\(G\\). La mencionada muestra es una muestra de referencia en el contexto de control de calidad y se considera como medidas de los productos producidos en un proceso bajo control. Sean \\(X_1,X_2,\\ldots,X_n\\) las nuevas observaciones provenientes del proceso de manufactura, se asume que siguen una distribución \\(F\\), si la calidad del producto se ha deteriorado o si el proceso está fuera de control, caso contrario siguen una distribución \\(G\\). Si se ordenan todas las profundidades \\(D_{G}\\left(Y_{}\\right)\\) en orden ascendente y se usa \\(Y_{\\left[ j\\right] }\\) para denominar al punto de la muestra asociado con el \\(j-\\)ésimo valor de profundidad más pequeño, entonces \\(Y_{\\left[ 1\\right]},\\ldots,Y_{\\left[ m\\right]}\\) siendo \\(Y_{\\left[ m\\right]}\\) el punto más central. Mientras más pequeño el índice (o rango) de un punto, más externo será ese punto respecto de la distribución subyacente \\(G\\left( .\\right)\\). Liu (Liu, 1995) define el rango (Rank): \\(r_{G}\\left( y\\right)= P\\left\\lbrace D_{G}\\left( Y\\right) \\leq D_{G}\\left( y\\right) \\mid Y\\sim G \\right\\rbrace\\) \\(Y\\sim G\\) indica que la variable aleatoria \\(Y\\) sigue la distribución \\(G\\). Para el caso en que \\(G\\) es desconocida y sólo se conoce la muestra \\(\\left\\lbrace Y_{1},\\ldots,Y_{m} \\right\\rbrace\\): \\(r_{G_{m}}\\left( y\\right)= \\frac{ \\sharp \\left\\lbrace D_{G_{m}}\\left( Y_j\\right) \\leq D_{G_{m}}\\left( y\\right), j = 1,\\ldots,m \\right\\rbrace}{m}\\) Si \\(F_{n}\\left( .\\right)\\) representa la distribución empírica de la muestra \\(X_1,X_2, ...,X_n\\) entonces en el mismo trabajo, Liu define, (Liu, 1995). índice \\(Q\\): \\(Q\\left( G,F\\right)= P\\left\\lbrace D_{G}\\left( Y\\right) \\leq D_{G}\\left( X\\right) \\mid Y\\sim G, X\\sim F \\right\\rbrace=E_{F}\\left[ r_{G}\\left( X\\right) \\right]\\) \\(Q\\left( G,F_{n}\\right)= \\frac{1}{n} \\sum _{=1}^{n} r_{G}\\left( X_i\\right)\\) \\(Q\\left( G_{m},F_{n}\\right)= \\frac{1}{n} \\sum _{=1}^{n} r_{G_{m}}\\left( X_i\\right)\\)","code":""},{"path":"https://mflores72000.github.io/qcr/articles/Npqcc.html","id":"gráfico-de-control-r","dir":"Articles","previous_headings":"Gráficos de control de la calidad no paramétricos","what":"Gráfico de control r","title":"Gráficos de control de la calidad no paramétricos","text":"Se calcula \\(\\left\\lbrace r_{G}\\left( X_1\\right),r_{G}\\left( X_2\\right),\\ldots,r_{G}\\left( X_n\\right)\\right\\rbrace\\) ó \\(\\left\\lbrace r_{G_{m}}\\left( X_1\\right),r_{G_{m}}\\left( X_2\\right),\\ldots,r_{G_{m}}\\left( X_n\\right)\\right\\rbrace\\) si sólo está disponible \\(Y_1,\\ldots,Y_m\\) pero \\(G\\). El gráfico de control r, consiste en graficar el estadístico rank versus el tiempo. Cuyo límite de control central \\(LC = 0.5\\) y límite inferior es \\(LCI = \\alpha\\), donde \\(\\alpha\\) es la tasa de falsa alarma. El proceso es declarado fuera de control si al menos uno de los estadísticos rank cae bajo \\(LCI\\). Un valor pequeño del estadístico rank \\(r_{G_{m}}\\left( X\\right)\\) significa que sólo una muy pequeña proporción de \\(Y_i~^{'}\\) son más externos que \\(X\\). Entonces, si se asume que \\(X \\sim F\\) entonces un valor pequeño de \\(r_{G_{m}}\\left( X\\right)\\) sugiere una posible desviación desde \\(G\\) \\(F\\). Esta puede ser por un desplazamiento en la localización y/o un incremento en escala de la variable de calidad. Aunque el gráfico r dispone de la línea UCL para hacer de CL la línea central de la región bajo control, la línea CL sirve como punto de referencia que permite observar si aparece o se está gestando un patrón o tendencia en una secuencia de muestras. Sí \\(r_{G_{m}}\\left( X\\right)\\) es mayor que \\(0.5\\); hay indicios de una disminución en escala con quizás un despreciable desplazamiento de localización. Esto es visto como una mejora en calidad dada una ganancia en la precisión, y así el proceso se vería como fuera de control.","code":"set.seed(356) mu<-c(0,0) Sigma<- matrix(c(1,0,0,1),nrow = 2,ncol = 2) u <- c(2,2) S <- matrix(c(4,0,0,4),nrow = 2,ncol = 2) G <- rmvnorm(540, mean = mu, sigma = Sigma) x<- rmvnorm(40,mean=u,sigma = S) x <- rbind(G[501:540,],x) M <- G[1:500,] data.npqcd <- npqcd(x,M) str(data.npqcd) #> List of 2 #>  $ x: num [1:80, 1:2, 1] 0.995 -1.274 -1.174 -0.347 0.931 ... #>  $ G: num [1:500, 1:2] 0.306 -0.322 1.389 1.438 -0.784 ... #>  - attr(*, \"data.name\")= chr \"DATA\" #>  - attr(*, \"type.data\")= chr \"Multivariate\" #>  - attr(*, \"class\")= chr [1:2] \"npqcd\" \"list\" res.npqcs <- npqcs.r(data.npqcd,method = \"Liu\", alpha=0.025) str(res.npqcs) #> List of 9 #>  $ npqcd     :List of 2 #>   ..$ x: num [1:80, 1:2, 1] 0.995 -1.274 -1.174 -0.347 0.931 ... #>   ..$ G: num [1:500, 1:2] 0.306 -0.322 1.389 1.438 -0.784 ... #>   ..- attr(*, \"data.name\")= chr \"DATA\" #>   ..- attr(*, \"type.data\")= chr \"Multivariate\" #>   ..- attr(*, \"class\")= chr [1:2] \"npqcd\" \"list\" #>  $ type      : chr \"r\" #>  $ depth.data: num [1:80, 1] 0.0243 0.0866 0.0292 0.2412 0.1214 ... #>  $ statistics: num [1:80, 1] 0.242 0.532 0.268 0.974 0.666 0.268 0.42 0.136 0.824 0.118 ... #>  $ alpha     : num 0.025 #>  $ limits    : Named num [1:2] 0.025 0.5 #>   ..- attr(*, \"names\")= chr [1:2] \"lcl\" \"cl\" #>  $ data.name : chr \"DATA\" #>  $ method    : chr \"Liu\" #>  $ violations: int [1:25] 42 43 44 46 48 49 50 52 53 54 ... #>  - attr(*, \"class\")= chr [1:2] \"npqcs.r\" \"npqcs\" summary(res.npqcs) #>  #> Summary of group statistics: #>        V1         #>  Min.   :0.0140   #>  1st Qu.:0.0140   #>  Median :0.1970   #>  Mean   :0.3018   #>  3rd Qu.:0.4810   #>  Max.   :0.9760   #>  #> Number of quality characteristics:  2 #> Number of samples or observations:  80 #> Number of observations or sample size:  1 #> Control limits:  #>   lcl    cl  #> 0.025 0.500  #>  #> Beyond limits of control:  #>  [1] 0.014 0.014 0.014 0.014 0.014 0.014 0.014 0.014 0.014 0.014 0.014 0.014 #> [13] 0.014 0.014 0.014 0.014 0.016 0.014 0.014 0.014 0.014 0.014 0.014 0.014 #> [25] 0.014 plot(res.npqcs,title =\" r Control Chart\")"},{"path":"https://mflores72000.github.io/qcr/articles/Npqcc.html","id":"gráfico-de-control-q","dir":"Articles","previous_headings":"Gráficos de control de la calidad no paramétricos","what":"Gráfico de control Q","title":"Gráficos de control de la calidad no paramétricos","text":"La idea detrás del gráfico Q es similar la del gráfico \\(\\bar{X}\\). Si \\(X_1,X_2,\\ldots\\) son univariadas y \\(G\\) es normal, el gráfico \\(\\bar{X}\\) dibuja los promedios de subconjuntos consecutivos de tamaño. Una característica de este gráfico, es que puede prevenir una falsa alarma cuando el proceso en realidad está en control pero algún punto de la muestra individual cayó fuera de los límites de control debido sólo fluctuaciones aleatorias. Esta es una ventaja del gráfico \\(\\bar{X}\\) sobre el gráfico \\(X\\). Para el caso del gráfico Q, se dibuja los promedios de subconjuntos consecutivos de tama~o n, del estadístico rank (\\(r_{G}\\left( X_i\\right)\\) ó \\(r_{G_{m}}\\left( X_i\\right)\\)) que se denota por \\(Q\\left( G,F_{n}^j\\right)\\) ó \\(Q\\left( G_{m},F_{n}^j\\right)\\), aquí \\(F_n^j\\) es la distribución empírica de los \\(X_i\\). El gráfico Q dibuja los siguientes conjuntos de puntos: \\(\\left\\lbrace Q\\left( G_{m},F_{n}^j\\right),Q\\left( G_{m},F_{n}^j\\right),.\\ldots\\right\\rbrace\\), si sólo se dispone de \\(\\left\\lbrace Y_1, Y_2,\\ldots, Y_m \\right\\rbrace\\). Los límites de control son los siguientes: \\(n \\geq 5\\) \\(CL = 0.5; LCL = 0.5-Z_{\\alpha}\\left( 12n\\right)^{\\frac{1}{2}} \\quad para \\quad dibujar \\quad Q\\left( G,F_{n}^j\\right)\\) \\(CL = 0.5; LCL = 0.5-Z_{\\alpha}\\sqrt{\\frac{1}{12•}\\left(\\frac{1}{m}+\\frac{1}{n}\\right) } \\quad para \\quad dibujar \\quad Q\\left( G_m,F_{n}^j\\right)\\) \\(n < 5\\) \\(CL = 0.5; LCL = \\frac{\\left( n!\\alpha\\right)^{\\frac{1}{n}}}{n}\\)","code":"set.seed(12345) mu<-c(0,0) Sigma<- matrix(c(1,0,0,1),nrow = 2,ncol = 2) u <- c(2,2) S <- matrix(c(4,0,0,4),nrow = 2,ncol = 2) G <- rmvnorm(540, mean = mu, sigma = Sigma) x<- rmvnorm(40,mean=u,sigma = S) x <- rbind(G[501:540,],x) n <- 4 # samples m <- 20  # measurements k <- 2  # number of variables x.a <- array(,dim=c(n,k,m)) for (i in 1:m){   x.a[,,i] <- x[(1+(i-1)*n):(i*n),] } M <- G[1:500,] data.npqcd <- npqcd(x.a,M) str(data.npqcd) #> List of 2 #>  $ x: num [1:4, 1:2, 1:20] 1.6775 -0.8564 -0.3809 -0.0718 0.0795 ... #>  $ G: num [1:500, 1:2] 0.586 -0.109 0.606 0.63 -0.284 ... #>  - attr(*, \"data.name\")= chr \"DATA\" #>  - attr(*, \"type.data\")= chr \"Multivariate\" #>  - attr(*, \"class\")= chr [1:2] \"npqcd\" \"list\" res.npqcs <- npqcs.Q(data.npqcd,method = \"Liu\", alpha=0.025) str(res.npqcs) #> List of 8 #>  $ npqcd     :List of 2 #>   ..$ x: num [1:4, 1:2, 1:20] 1.6775 -0.8564 -0.3809 -0.0718 0.0795 ... #>   ..$ G: num [1:500, 1:2] 0.586 -0.109 0.606 0.63 -0.284 ... #>   ..- attr(*, \"data.name\")= chr \"DATA\" #>   ..- attr(*, \"type.data\")= chr \"Multivariate\" #>   ..- attr(*, \"class\")= chr [1:2] \"npqcd\" \"list\" #>  $ type      : chr \"Q\" #>  $ statistics: num [1:20] 0.352 0.604 0.346 0.623 0.456 ... #>  $ alpha     : num 0.025 #>  $ limits    : Named num [1:2] 0.22 0.5 #>   ..- attr(*, \"names\")= chr [1:2] \"lcl\" \"cl\" #>  $ data.name : chr \"DATA\" #>  $ method    : chr \"Liu\" #>  $ violations: int [1:10] 11 12 13 14 15 16 17 18 19 20 #>  - attr(*, \"class\")= chr [1:2] \"npqcs.Q\" \"npqcs\" summary(res.npqcs) #>  #> Summary of group statistics: #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #> 0.01400 0.08637 0.25725 0.28715 0.46450 0.62350  #>  #> Number of quality characteristics:  2 #> Number of samples or observations:  4 #> Number of observations or sample size:  20 #> Control limits:  #>       lcl        cl  #> 0.2200279 0.5000000  #>  #> Beyond limits of control:  #>  [1] 0.1135 0.1580 0.0590 0.1680 0.0565 0.0900 0.0140 0.0755 0.0640 0.1115 plot(res.npqcs,title =\" Q Control Chart\")"},{"path":"https://mflores72000.github.io/qcr/articles/Npqcc.html","id":"gráfico-de-control-s","dir":"Articles","previous_headings":"Gráficos de control de la calidad no paramétricos","what":"Gráfico de control S","title":"Gráficos de control de la calidad no paramétricos","text":"El gráfico de control S se inspira en el gráfico de control univariado CUSUM. Esta dibuja \\(\\sum_{=1}^{n}\\left( X - \\mu \\right)\\) lo cual refleja el patrón de la desviación total del valor esperado. Este gráfico de control es más efectivo que los gráficos \\(X\\) o \\(\\bar{X}\\) en detectar pequeños cambios del proceso. En el gráfico de control S se dibujan los puntos correspondientes las expresiones siguientes: En el caso de contar con \\(G\\): \\(S_n\\left( G\\right) = \\sum_{=1}^{n}\\left( r_G\\left( X_i\\right) - \\frac{1}{2} \\right)\\) Los límites de control son los siguientes: \\(CL = 0; LCL = -Z_{\\alpha}\\left(\\frac{n}{12}\\right)^{\\frac{1}{2}}\\) En el caso de contar con \\(Y_1,\\ldots,Y_m\\): \\(S_n\\left( G_m\\right) = \\sum_{=1}^{n}\\left( r_{G_{m}}\\left( X_i\\right) - \\frac{1}{2} \\right)\\) Los Límites de Control son los siguientes: \\(CL = 0; LCL = -Z_{\\alpha}\\sqrt{n^2\\frac{\\left(\\frac{1}{m}+\\frac{1}{n}\\right)}{12}}\\) Los límites de control LCL en ambos casos constituyen una curva en vez de una recta; si n es grande el gráfico de control S fácilmente excedería el tamaño del papel, por lo que se estandariza de la siguiente manera respectivamente: \\(S_n^{*}\\left( G\\right) = \\frac{S_n^{*}\\left(G\\right)}{\\sqrt{\\frac{n}{12}}}\\) \\(S_n^{*}\\left( G_m\\right) = \\frac{S_n\\left(G_m\\right)}{\\sqrt{n^2\\frac{\\left(\\frac{1}{m}+\\frac{1}{n}\\right)}{12}}}\\) Los límites de control en los dos casos son los siguientes: \\(CL = 0; LCL = -Z_{\\alpha}\\)","code":"set.seed(12345) mu<-c(0,0) Sigma<- matrix(c(1,0,0,1),nrow = 2,ncol = 2) u <- c(2,2) S <- matrix(c(4,0,0,4),nrow = 2,ncol = 2) G <- rmvnorm(540, mean = mu, sigma = Sigma) x<- rmvnorm(40,mean=u,sigma = S) x.a <- rbind(G[501:540,],x) M <- G[1:500,] data.npqcd <- npqcd(x.a,M) str(data.npqcd) #> List of 2 #>  $ x: num [1:80, 1:2, 1] 1.6775 -0.8564 -0.3809 -0.0718 0.6707 ... #>  $ G: num [1:500, 1:2] 0.586 -0.109 0.606 0.63 -0.284 ... #>  - attr(*, \"data.name\")= chr \"DATA\" #>  - attr(*, \"type.data\")= chr \"Multivariate\" #>  - attr(*, \"class\")= chr [1:2] \"npqcd\" \"list\" res.npqcs <- npqcs.S(data.npqcd,method = \"Liu\", alpha=0.05) str(res.npqcs) #> List of 8 #>  $ npqcd     :List of 2 #>   ..$ x: num [1:80, 1:2, 1] 1.6775 -0.8564 -0.3809 -0.0718 0.6707 ... #>   ..$ G: num [1:500, 1:2] 0.586 -0.109 0.606 0.63 -0.284 ... #>   ..- attr(*, \"data.name\")= chr \"DATA\" #>   ..- attr(*, \"type.data\")= chr \"Multivariate\" #>   ..- attr(*, \"class\")= chr [1:2] \"npqcd\" \"list\" #>  $ type      : chr \"S\" #>  $ statistics: num [1:80] -0.741 -0.66 -1.292 -1.025 -0.515 ... #>  $ alpha     : num 0.05 #>  $ limits    : Named num [1:2] 0 -1.64 #>   ..- attr(*, \"names\")= chr [1:2] \"cl\" \"lcl\" #>  $ data.name : chr \"DATA\" #>  $ method    : chr \"Liu\" #>  $ violations: int [1:33] 48 49 50 51 52 53 54 55 56 57 ... #>  - attr(*, \"class\")= chr [1:2] \"npqcs.S\" \"npqcs\" summary(res.npqcs) #>  #> Summary of group statistics: #>     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.  #> -6.12323 -3.58085 -0.85896 -2.00763 -0.42436  0.03105  #>  #> Number of quality characteristics:  2 #> Number of samples or observations:  80 #> Number of observations or sample size:  1 #> Control limits:  #>        cl       lcl  #>  0.000000 -1.644854  #>  #> Beyond limits of control:  #>  [1] -1.710765 -1.836190 -2.043093 -2.245696 -2.444181 -2.638716 -2.829460 #>  [8] -2.937644 -2.929749 -3.040439 -3.220669 -3.397692 -3.569932 -3.613600 #> [15] -3.782822 -3.949234 -4.112929 -4.273995 -4.432519 -4.588579 -4.742254 #> [22] -4.893616 -4.947340 -5.095040 -5.240611 -5.384115 -5.525610 -5.665153 #> [29] -5.728754 -5.743827 -5.879246 -6.012889 -6.123226 plot(res.npqcs,title =\" S Control Chart\")"},{"path":[]},{"path":"https://mflores72000.github.io/qcr/articles/Uqcc.html","id":"gráficos-para-la-media-y-el-rango","dir":"Articles","previous_headings":"Gráficos de control de la calidad univariantes","what":"Gráficos para la media y el rango","title":"Gráficos de control de la calidad univariantes","text":"Calcular la media y el rango de cada muestra, \\(\\bar{x}_i\\) y \\(R_i\\), respectivamente \\(=1,\\dots,k\\). Calcular la media y el rango global. Puesto que \\(R_i/d_2\\) es un estimador insesgado de \\(\\sigma\\), y definiendo \\[ \\bar{R}=\\frac{\\sum_iR_i}{k} \\] se utilizará \\[ \\frac{\\bar{R}}{d_2}=\\frac{\\sum_iR_i}{d_2k} \\] como estimador centrado de la desviación típica teórica. Contrastar si cada valor \\(\\bar{x}_i\\) debe estar en el intervalo \\[ \\left[\\bar{\\bar{x}}-\\frac{3\\bar{R}}{\\sqrt{n}d_2},\\bar{\\bar{x}}+\\frac{3\\bar{R}}{\\sqrt{n}d_2}\\right] \\] con probabilidad aproximada del 97.73% (utilizando intervalos de amplitud \\(3\\sigma\\)) Podremos encontrar los valores de los límites de control \\(3\\sigma\\) para la media como: \\(LCL = \\bar{\\bar{x}}-\\frac{3}{\\sqrt{n}d_2}\\bar{R}=\\bar{\\bar{x}}-A_2\\bar{R}\\) \\(CL = \\bar{\\bar{x}}\\) \\(UCL = \\bar{\\bar{x}}+\\frac{3}{\\sqrt{n}d_2}\\bar{R}=\\bar{\\bar{x}}+A_2\\bar{R}\\)","code":"x <- droplevels(pistonrings[1:125,]) res.qcs <- qcs.xbar(x, data.name=\"pistonrings\", std.dev = \"UWAVE-R\") plot(res.qcs, title = expression(paste(\"Gráfico de control para pistonrings:\", bar(x),\" \")))"},{"path":"https://mflores72000.github.io/qcr/articles/Uqcc.html","id":"gráficos-r","dir":"Articles","previous_headings":"Gráficos de control de la calidad univariantes","what":"Gráficos R","title":"Gráficos de control de la calidad univariantes","text":"Dado \\(n\\), encontrar los valores \\(D_3\\) y \\(D_4\\) y calcular \\(\\bar{R}\\). Con todo ello obtener los límites inferior \\(D_3\\bar{R}\\) y superior \\(D_4\\bar{R}\\) de control. Construir un gráfico que presente en abscisas y en ordenadas los valores \\(R_i\\). Trazar también la línea central (\\(\\bar{R}\\)) y los límites de control (\\(D_3\\bar{R}\\) y \\(D_4\\bar{R}\\)). Si alguna de los rangos se sale de los límites de control, se admite que el proceso está bajo control en ese instante.","code":"x <- droplevels(pistonrings[1:125,]) res.qcs <- qcs.R(x, data.name=\"pistonrings\",std.dev = \"UWAVE-R\") plot(res.qcs, title = \"Gráfico de control para pistonrings: R\")"},{"path":"https://mflores72000.github.io/qcr/articles/Uqcc.html","id":"gráficos-para-la-media-y-la-desviación-estándar","dir":"Articles","previous_headings":"Gráficos de control de la calidad univariantes","what":"Gráficos para la media y la desviación estándar","title":"Gráficos de control de la calidad univariantes","text":"Calcular la media y la desviación típica de cada muestra, \\(\\bar{x}_i\\) y \\(s_i\\), respectivamente \\(=1,\\dots,k\\). Calcular la media y la desviación típica global. La media global \\(\\bar{\\bar{x}}\\) resulta ser un estimador insesgado de la media teórica. Como la desviación típica muestral es un estimador sesgado de la desviación típica teórica, se utilizará \\(s_i/c_2\\), siendo \\(c_2\\) una constante dependiente de \\(n\\) y por ello se utilizará \\[ \\hat{\\sigma}=\\frac{\\bar{s}}{c_2}=\\frac{\\sum_is_i}{c_2k} \\] como estimador centrado de la desviación típica teórica.} Contrastar si cada valor \\(\\bar{x}_i\\) está en el intervalo \\[ \\left[\\bar{\\bar{x}}-\\frac{3\\bar{s}}{\\sqrt{n}c_2},\\bar{\\bar{x}}+\\frac{3\\bar{s}}{\\sqrt{n}c_2}\\right] \\] con probabilidad aproximada del 97.74%. Podremos encontrar los valores de los límites de control \\(3\\sigma\\) para la media como: \\(LCL = \\bar{\\bar{x}}-\\frac{3}{\\sqrt{n}c_2}\\bar{s}=\\bar{\\bar{x}}-A_1\\bar{s}\\) \\(CL = \\bar{\\bar{x}}\\) \\(UCL = \\bar{\\bar{x}}+\\frac{3}{\\sqrt{n}c_2}\\bar{s}=\\bar{\\bar{x}}+A_1\\bar{s}\\)","code":"x <- droplevels(pistonrings[1:125,]) res.qcs <- qcs.xbar(x, data.name = \"pistonrings\", std.dev = \"UWAVE-SD\") plot(res.qcs, title = expression(paste(\"Gráfico de control para pistonrings:\", bar(x),\" \")))"},{"path":"https://mflores72000.github.io/qcr/articles/Uqcc.html","id":"gráfico-s","dir":"Articles","previous_headings":"Gráficos de control de la calidad univariantes","what":"Gráfico s","title":"Gráficos de control de la calidad univariantes","text":"Dado \\(n\\), encontrar los valores \\(B_3\\) y \\(B_4\\) y calcular \\(\\bar{s}\\). Con todo ello obtener los límites inferior \\(B_3\\bar{s}\\) y superior \\(B_4\\bar{s}\\) de control. Construir un gráfico que presente en abscisas y en ordenadas los valores \\(s_i\\). Trazar también la línea central (\\(\\bar{s}\\)) y los límites de control (\\(B_3\\bar{s}\\) y \\(B_4\\bar{s}\\)). Si alguna de las desviaciones típicas se sale de los límites de control, se admite que el proceso está bajo control en ese instante.","code":"x <- droplevels(pistonrings[1:125,]) res.qcs <- qcs.S(x, data.name = \"pistonrings\", std.dev = \"UWAVE-SD\") plot(res.qcs, title = \"Gráfico de control para pistonrings: S\")"},{"path":"https://mflores72000.github.io/qcr/articles/Uqcc.html","id":"gráficos-p","dir":"Articles","previous_headings":"Gráficos de control de la calidad univariantes","what":"Gráficos \\(p\\)","title":"Gráficos de control de la calidad univariantes","text":"Supóngase un artículo está conforme con probabilidad \\(p\\), y que los artículos producidos sucesivamente son independientes; si seleccionamos \\(k\\) muestras aleatorias de \\(n\\) artículos, y representando por \\(X_i\\) al número de artículos defectuosos, tendremos que \\(X_i\\sim B(n,p)\\). Sabemos que \\(\\mu=np\\) y \\(\\sigma=\\sqrt{np(1-p)}\\). Para cada muestra, definimos la variable aleatoria fracción disconforme muestral como \\(\\hat{p}_i=\\frac{X_i}{n}\\). Observar que \\(\\hat{p}_i\\) seguirá una distribución binomial con varianza: \\(E(\\hat{p}_i)=\\frac{E(X_i)}{n}=p\\) \\(Var(\\hat{p}_i)=\\frac{Var(X_i)}{n^2}=\\frac{p(1-p)}{n}\\). Por tanto, \\(\\lim_{n\\rightarrow \\infty}\\hat{p}_i=N\\left( p,\\sqrt{\\frac{p(1-p)}{n}} \\right)\\). Si \\(p\\) es desconocida, la podemos estimar: \\(\\bar{p}=\\frac{1}{k}\\sum_{=1}^{k}\\hat{p}_i\\). Según el modelo de Shewart tendremos que: \\(LCL = \\bar{p}-3\\sqrt{\\frac{\\bar{p}(1-\\bar{p})}{n}}\\) \\(CL = \\bar{p}\\) \\(UCL = \\bar{p}+3\\sqrt{\\frac{\\bar{p}(1-\\bar{p})}{n}}\\) En caso de que el tamaño muestral (\\(n_i\\)) diferentes, el estimador para \\(p\\) ser??: \\(\\bar{p}=\\frac{\\sum_{=1}^{k}n_i\\hat{p}_i}{\\sum_{=1}^{k}n_i}.\\) Datos Jugo de naranja (orangejuice): Es un data frame con 54 Observaciones y 4 variables. Donde se mide el jugo de naranja concentrado congelado que se envasa en latas de cartón de 6 oz. Estas latas se forman en una máquina de hilatura. Una lata es inspeccionado para determinar si, cuando se llena, el líquido puede derramarse ya sea en la costura lateral o alrededor de la articulación de la parte inferior. Si esto ocurre, una lata se considera conforme. Se tomaron 30 muestras de 50 latas cada una en intervalos de media hora durante un período de tres turnos (la máquina estaba en funcionamiento continuo). partir de la muestra 15 se utiliza un nuevo bacth de stock. Las variables del data frame son: sample (muestra): identificación de la muestra D: número de unidades defectuosas size (tamaño): tamaño de la muestra trial (ensayo): muestras de prueba (verdadero / falso)","code":"data(orangejuice) str(orangejuice) #> 'data.frame':    54 obs. of  4 variables: #>  $ D     : int  12 15 8 10 4 7 16 9 14 10 ... #>  $ sample: int  1 2 3 4 5 6 7 8 9 10 ... #>  $ size  : int  50 50 50 50 50 50 50 50 50 50 ... #>  $ trial : logi  TRUE TRUE TRUE TRUE TRUE TRUE ...  datos.qcd <- qcd(data = orangejuice, var.index = 1, sample.index = 2,                 sizes = orangejuice$size, type.data = \"atributte\")  res.qcs <- qcs.p(datos.qcd) summary(res.qcs) #> p chart for orangejuice  #>  #> Summary of group statistics: #>        p          #>  Min.   :0.0400   #>  1st Qu.:0.1000   #>  Median :0.1400   #>  Mean   :0.1778   #>  3rd Qu.:0.2400   #>  Max.   :0.4800   #>  #> Group sample size:  50 #> Number of groups:  54 #> Center of group statistics:  0.1777778 #> Standard deviation:  0.3823256  #>  #> Control limits:  #>         LCL       UCL #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  #> Beyond limits of control:  #> [1] 0.34 0.44 0.40 0.36 0.48 #>  #> Violationg runs:  #>  [1] 0.18 0.24 0.12 0.04 0.08 0.06 0.12 0.10 0.08 0.16 0.10 0.12 0.14 0.10 0.12 #> [16] 0.06 0.10 plot(res.qcs) datos.qcs <- qcs.p(orangejuice[orangejuice$trial,c(1,2)], sizes = orangejuice[orangejuice$trial,3]) plot(datos.qcs)"},{"path":"https://mflores72000.github.io/qcr/articles/Uqcc.html","id":"gráfico-np","dir":"Articles","previous_headings":"Gráficos de control de la calidad univariantes","what":"Gráfico np","title":"Gráficos de control de la calidad univariantes","text":"En algunas ocasiones interesa analizar el número medio de disconformidades en lugar de su proporción; en este caso se utilizarón los llamados gráficos NP. Para la construcción de este tipo de gráficos se estimarán las proporciones de la misma forma que en los gráficos P pero se construirán los gráficos basados en la media del proceso del siguiente modo: \\(LCL = n\\bar{p}-3\\sqrt{\\frac{n\\bar{p}(1-\\bar{p})}{n}}\\) \\(CL = n\\bar{p}\\) \\(UCL = n\\bar{p}+3\\sqrt{\\frac{n\\bar{p}(1-\\bar{p})}{n}}\\)","code":"data(orangejuice) str(orangejuice) #> 'data.frame':    54 obs. of  4 variables: #>  $ D     : int  12 15 8 10 4 7 16 9 14 10 ... #>  $ sample: int  1 2 3 4 5 6 7 8 9 10 ... #>  $ size  : int  50 50 50 50 50 50 50 50 50 50 ... #>  $ trial : logi  TRUE TRUE TRUE TRUE TRUE TRUE ... datos.qcd <- qcd(data = orangejuice, var.index = 1, sample.index = 2,                 sizes = orangejuice$size, type.data = \"atributte\")  res.qcs <- qcs.np(datos.qcd) summary(res.qcs) #> np chart for orangejuice  #>  #> Summary of group statistics: #>        np         #>  Min.   : 2.000   #>  1st Qu.: 5.000   #>  Median : 7.000   #>  Mean   : 8.889   #>  3rd Qu.:12.000   #>  Max.   :24.000   #>  #> Group sample size:  50 #> Number of groups:  54 #> Center of group statistics:  8.888889 #> Standard deviation:  2.70345  #>  #> Control limits:  #>        LCL      UCL #>  0.7785388 16.99924 #>  #> Beyond limits of control:  #> [1] 17 22 20 18 24 #>  #> Violationg runs:  #>  [1]  9 12  6  2  4  3  6  5  4  8  5  6  7  5  6  3  5 plot(res.qcs) datos.qcs <- qcs.np(orangejuice[orangejuice$trial,c(1,2)], sizes = orangejuice[orangejuice$trial,3]) plot(datos.qcs)"},{"path":"https://mflores72000.github.io/qcr/articles/Uqcc.html","id":"gráfico-c","dir":"Articles","previous_headings":"Gráficos de control de la calidad univariantes","what":"Gráfico c","title":"Gráficos de control de la calidad univariantes","text":"Para construir el diagrama de control C empezamos por tomar \\(k\\) muestras \\(X1,X_2,\\dots,X_k\\) , de \\(n_i\\) unidades cada una, por ejemplo \\(X_i=(X_{i1},\\dots,X_{in_i})\\). Sea \\(u\\) el número esperado de unidades defectuosas en cada una de las muestras. Para cada muestra se calcula el número \\(u_{ij}\\) de defectos de la unidad \\(X_{ij}\\), \\(j=1,\\dots,n_i\\). Si denotamos por \\(c_i\\) al número de defectos totales en la muestra \\(\\)-ésima, es claro que + Por otro lado, si denotamos por \\(u_i\\) al valor esperado de defectos en la muestra \\(\\)-ésima, tendremos que \\(u_i=\\frac{1}{n_i}\\sum_{j=1}^{n_i}u_{ij}\\). Observar pues que \\(u_i=\\frac{1}{n_i}c_i\\), es decir, \\(c_i=u_in_i\\). Notar además que \\(\\mathbb{E}(c_i)=\\mathbb{E}(u_in_i)=n_i\\mathbb{E}(u_i)=n_iu\\).} Es frecuente suponer que el número de defectos (sucesos habituales) en una poblacion grande sigue una distribucion de Poisson: \\(c_i\\sim Poiss(n_iu)\\). Se cumplirá que \\(\\lim_{n\\rightarrow{\\infty}}c_i=N(n_iu,\\sqrt{n_iu})\\). Si \\(u=\\mathbb{E}[u_i]\\) es desconocida, la podemos estimar: \\[ \\hat{u}=\\frac{1}{k}\\sum_{=1}^{k}u_i. \\] Según el modelo de Shewart tendremos que: \\(LCL = n_i\\hat{u}-3\\sqrt{{\\hat{u}}{n_i}}\\) \\(CL = n_i\\hat{u}\\) \\(UCL = n_i\\hat{u}+3\\sqrt{{\\hat{u}}{n_i}}\\) Como el tamaño muestral (\\(n_i\\)) es diferente para cada subgrupo, para calcular los límites podemos optar por distintos métodos. Datos Placas impresas (Circuit boards data): Número de conformidades observadas en 26 muestras sucesivas de 100 placas de circuitos impresos. Muestra 6 y 20 están fuera de los límites de control. Muestra 6 fue examinado por un nuevo inspector que había reconocido varios tipos de conformidades. Además, el número inusualmente grande de las conformidades en la muestra 20 se debío un problema de control de la temperatura en la máquina de soldadura, que fue reparado subsequentemente. Los últimos 20 muestras son otras muestras recogidas en las unidades de inspección (cada una formada por 100 paneles). Las variables del data frame son: x : número de unidades defectuosas en 100 placas de circuito impreso (unidad de control) size (tamaño): tamaño de la muestra trial (ensayo) indicador muestra ensayo (verdadero / falso)","code":"data(circuit) str(circuit) #> 'data.frame':    46 obs. of  4 variables: #>  $ x     : int  21 24 16 12 15 5 28 20 31 25 ... #>  $ sample: int  1 2 3 4 5 6 7 8 9 10 ... #>  $ size  : int  100 100 100 100 100 100 100 100 100 100 ... #>  $ trial : logi  TRUE TRUE TRUE TRUE TRUE TRUE ... datos <- circuit datos$sample <- 1:length(datos$x) str(datos) #> 'data.frame':    46 obs. of  4 variables: #>  $ x     : int  21 24 16 12 15 5 28 20 31 25 ... #>  $ sample: int  1 2 3 4 5 6 7 8 9 10 ... #>  $ size  : int  100 100 100 100 100 100 100 100 100 100 ... #>  $ trial : logi  TRUE TRUE TRUE TRUE TRUE TRUE ...  datos.qcd <- qcd(data = datos, var.index = 1,sample.index = 2,                 sizes = 100, type.data = \"atributte\") res.qcs <- qcs.c(datos.qcd) summary(res.qcs) #> c chart for datos  #>  #> Summary of group statistics: #>        c         #>  Min.   : 5.00   #>  1st Qu.:16.00   #>  Median :19.00   #>  Mean   :19.17   #>  3rd Qu.:22.00   #>  Max.   :39.00   #>  #> Group sample size:  100 #> Number of groups:  46 #> Center of group statistics:  19.17391 #> Standard deviation:  4.378803  #>  #> Control limits:  #>       LCL      UCL #>  6.037505 32.31032 #>  #> Beyond limits of control:  #> [1] 39  5 #>  #> Violationg runs:  #> [1] 12 15 plot(res.qcs)"},{"path":"https://mflores72000.github.io/qcr/articles/Uqcc.html","id":"gráfico-cusum","dir":"Articles","previous_headings":"Gráficos de control de la calidad univariantes","what":"Gráfico Cusum","title":"Gráficos de control de la calidad univariantes","text":"Los gráficos CUSUM se basan en la decisión de comprobar si el proceso está bajo control o analizando toda o la mayor parte de la muestra. Para este fin se usará el estadístico \\(s_r\\): \\[ s_r=\\sum_{=1}^{r}(\\bar{x}_i-\\mu_0). \\] Bajo supuestos de normalidad es evidente deducir la distribución del estadístico \\(s_r\\): \\[ s_r\\N\\left( r(\\mu-\\mu_0), \\frac{r\\sigma_0^2}{n} \\right). \\]","code":"data(pistonrings) res.qcd <- qcd(pistonrings, type.data = \"dependence\") res.qcs <- qcs.cusum(res.qcd, type = \"cusum\") summary(res.qcs) #> cusum chart for pistonrings  #>  #> Summary of group statistics: #>      cusum       #>  Min.   :73.99   #>  1st Qu.:74.00   #>  Median :74.00   #>  Mean   :74.00   #>  3rd Qu.:74.01   #>  Max.   :74.02   #>  #> Group sample size:  5 #> Number of groups:  40 #> Center of group statistics:  74.0036 #> Standard deviation:  0.01007094  #>  #> Control limits:  #> [1] -5  5 #>  #> Beyond limits of control:  #>  [1] 73.9902 74.0060 73.9966 74.0008 74.0074 73.9982 74.0092 73.9998 74.0016 #> [10] 74.0024 73.9982 73.9922 73.9974 #>  #> Violationg runs:  #> [1] 74.0196 74.0234 74.0128 plot(res.qcs)"},{"path":"https://mflores72000.github.io/qcr/articles/Uqcc.html","id":"gráfico-ewma","dir":"Articles","previous_headings":"Gráficos de control de la calidad univariantes","what":"Gráfico Ewma","title":"Gráficos de control de la calidad univariantes","text":"En los gráficos EWMA se representan promedios de la observación contemporánea y las observaciones anteriores, donde se da más peso las observaciones más recientes (medias móviles \\(y_i\\)). Se define como: \\[ y_i=\\lambda x_i+(1-\\lambda)y_{-1} \\] Los límites de control y la línea central son entonces: \\(LCL = \\mu_0-3\\sigma\\sqrt{\\frac{\\lambda(1-(1-\\lambda)^{2i})}{2-\\lambda}}\\) \\(LCS = \\mu_0\\) \\(UCL = \\mu_0+3\\sigma\\sqrt{\\frac{\\lambda(1-(1-\\lambda)^{2i})}{2-\\lambda}}\\) Si \\(\\) es muy elevado se tiene que, aproximadamente, \\(LCL = \\mu_0-3\\sigma\\sqrt{\\frac{\\lambda}{2-\\lambda}}\\) \\(LCS = \\mu_0\\) \\(UCL = \\mu_0+3\\sigma\\sqrt{\\frac{\\lambda}{2-\\lambda}}\\)","code":"data(pistonrings)  res.qcd <- qcd(pistonrings, type.data = \"dependence\")  res.qcs <- qcs.ewma(res.qcd, type = \"ewma\")  summary(res.qcs)  plot(res.qcs)"},{"path":"https://mflores72000.github.io/qcr/articles/Uqcc.html","id":"ejemplos-gráfico-para-la-media","dir":"Articles","previous_headings":"Gráficos de control de la calidad univariantes","what":"Ejemplos Gráfico para la media","title":"Gráficos de control de la calidad univariantes","text":"En la siguiente sección se presentan gráficos de control para monitorizar la tendencia central de la variable de calidad: diamétro de los aros de los pistones.","code":""},{"path":"https://mflores72000.github.io/qcr/articles/Uqcc.html","id":"estabilizando-el-proceso","dir":"Articles","previous_headings":"Gráficos de control de la calidad univariantes > Ejemplos Gráfico para la media","what":"Estabilizando el proceso","title":"Gráficos de control de la calidad univariantes","text":"Se realiza un gráfico de medias para monitorizar el diámetro de los piston rings:  Se crea el objeto qcd (Quality Control Data) y el objeto qcs (Quality Control Statistics) del tipo xbar. Con el comando summary se obtienen las estimaciones de la media y la varianza así como los límites de control y con el comando plot se realiza el correspondiente gráfico de control. Además para indicar que el tipo de estimación de la varianza es por medio de Rangos, en la opción std.dev = “UWAVE-R” (método de estimación por defecto). Se puede observar tres puntos que indican que el proceso está fuera de control. Dos de estos salen fuera de los límites de control y un punto que está dentro de los límites pero corresponde una racha. Por tanto, el proceso esta bajo control. Se utiliza la función state.control que permite eliminar los puntos fuera de control y adempás devuelve un objeto del tipo qcd que se utiliza para construir un nuevo gráfico de control.  Aún existe un punto fuera de los límites de control. Se utiliza la función state.control para la eliminación de puntos fuera de control y se estiman los límites de control hasta que el proceso este bajo control, es decir, existan puntos fuera de los límites o rachas.","code":"str(pistonrings) #> 'data.frame':    200 obs. of  3 variables: #>  $ diameter: num  74 74 74 74 74 ... #>  $ sample  : int  1 1 1 1 1 2 2 2 2 2 ... #>  $ trial   : logi  TRUE TRUE TRUE TRUE TRUE TRUE ... pistonrings.qcd<-qcd(pistonrings) class(pistonrings.qcd) #> [1] \"qcd\"        \"data.frame\"  res.qcs <- qcs.xbar(pistonrings.qcd) plot(res.qcs,title=\"Control Chart Xbar for pistonrings I\", std.dev = \"UWAVE-R\") summary(res.qcs)   #> xbar chart for pistonrings  #>  #> Summary of group statistics: #>       xbar       #>  Min.   :73.99   #>  1st Qu.:74.00   #>  Median :74.00   #>  Mean   :74.00   #>  3rd Qu.:74.01   #>  Max.   :74.02   #>  #> Group sample size:  5 #> Number of groups:  40 #> Center of group statistics:  74.0036 #> Standard deviation:  0.01007094  #>  #> Control limits:  #>       LCL      UCL #>  73.99009 74.01712 #>  #> Beyond limits of control:  #> [1] 74.0196 74.0234 #>  #> Violationg runs:  #> [1] 74.0128 res.qcd <- state.control(res.qcs) res.qcs <- qcs.xbar(res.qcd) plot(res.qcs,title=\"Control Chart Xbar for pistonrings II\") summary(res.qcs)   #> xbar chart for pistonrings  #>  #> Summary of group statistics: #>       xbar       #>  Min.   :73.99   #>  1st Qu.:74.00   #>  Median :74.00   #>  Mean   :74.00   #>  3rd Qu.:74.01   #>  Max.   :74.02   #>  #> Group sample size:  5 #> Number of groups:  37 #> Center of group statistics:  74.00239 #> Standard deviation:  0.009992796  #>  #> Control limits:  #>       LCL     UCL #>  73.98898 74.0158 #>  #> Beyond limits of control:  #> [1] 74.0166 #>  #> Number violationg runs: 0 res.qcd <- state.control(res.qcs) res.qcs <- qcs.xbar(res.qcd) plot(res.qcs,title=\"Control Chart Xbar for pistonrings III\") summary(res.qcs)   #> xbar chart for pistonrings  #>  #> Summary of group statistics: #>       xbar       #>  Min.   :73.99   #>  1st Qu.:74.00   #>  Median :74.00   #>  Mean   :74.00   #>  3rd Qu.:74.01   #>  Max.   :74.01   #>  #> Group sample size:  5 #> Number of groups:  36 #> Center of group statistics:  74.00199 #> Standard deviation:  0.01004347  #>  #> Control limits:  #>       LCL      UCL #>  73.98852 74.01547 #>  #> Number beyond limits: 0  #>  #> Number violationg runs: 0"},{"path":"https://mflores72000.github.io/qcr/articles/Uqcc.html","id":"monitoriando-un-proceso","dir":"Articles","previous_headings":"Gráficos de control de la calidad univariantes","what":"Monitoriando un proceso","title":"Gráficos de control de la calidad univariantes","text":"En este ejemplo se parte de un proceso bajo control (Fase ) y una vez calculado los límites se realiza la monitorización del proceso (Fase II). Para la Fase se considera las primeras 25 muestras de los datos de piston rings y para la Fase II se utilizan el resto de las muestras.","code":"x <- droplevels(pistonrings[1:125,]) y <- droplevels(pistonrings[126:200,])  res.qcs <- qcs.xbar(x, data.name=\"Control Chart Xbar for pistonrings\") plot(res.qcs) res.qcs <- qcs.add(x = res.qcs, value = y[,c(1,2)])  plot(res.qcs) summary(res.qcs) #> xbar chart for Control Chart Xbar for pistonrings  #>  #> Summary of group statistics: #>       xbar       #>  Min.   :73.99   #>  1st Qu.:74.00   #>  Median :74.00   #>  Mean   :74.00   #>  3rd Qu.:74.01   #>  Max.   :74.02   #>  #> Group sample size:  5 #> Number of groups:  40 #> Center of group statistics:  74.0036 #> Standard deviation:  0.01007094  #>  #> Control limits:  #>       LCL     UCL #>  73.98805 74.0143 #>  #> Beyond limits of control:  #> [1] 74.0166 74.0196 74.0234 #>  #> Violationg runs:  #> [1] 74.0128"},{"path":"https://mflores72000.github.io/qcr/articles/Uqcc.html","id":"límites-de-alerta","dir":"Articles","previous_headings":"Gráficos de control de la calidad univariantes","what":"Límites de alerta","title":"Gráficos de control de la calidad univariantes","text":"","code":"x <- droplevels(pistonrings[1:125,]) res.qcs <- qcs.xbar(x, data.name=\"Control Chart Xbar for pistonrings\") plot(res.qcs,conf.nsigma.alert=2)"},{"path":"https://mflores72000.github.io/qcr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Miguel Flores. Author, maintainer. Ruben Fernandez-Casal. Author. Salvador Naya. Author. Javier Tarrio-Saavedra. Author.","code":""},{"path":"https://mflores72000.github.io/qcr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Flores M, Fernandez-Casal R, Naya S, Tarrio-Saavedra J (2021). qcr: Quality Control Review. R package version 1.3, https://CRAN.R-project.org/package=qcr.","code":"@Manual{,   title = {qcr: Quality Control Review},   author = {Miguel Flores and Ruben Fernandez-Casal and Salvador Naya and Javier Tarrio-Saavedra},   year = {2021},   note = {R package version 1.3},   url = {https://CRAN.R-project.org/package=qcr}, }"},{"path":[]},{"path":"https://mflores72000.github.io/qcr/index.html","id":"version-13","dir":"","previous_headings":"","what":"Version 1.3","title":"Quality Control Review","text":"package implements univariate multivariate Statistical Quality Control (SQC) tools completes increases SQC techniques available R. Apart integrating different R packages devoted SQC (qcc,MSQC), provides nonparametric tools highly useful Gaussian assumption met. package computes standard univariate control charts individual measurements, X-bar, S, R, p, np, c, u, EWMA CUSUM. package also includes functions perform multivariate control charts Hotelling T2, MEWMA MCUSUM. representative feature, multivariate nonparametric alternatives based data depth implemented package: r, Q S control charts. addition, Phase II control charts functional data included. package also allows estimation complete set capability indices first fourth generation, covering nonparametric alternatives, performing corresponding capability analysis graphical outputs, including process capability plots.","code":""},{"path":"https://mflores72000.github.io/qcr/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Quality Control Review","text":"Flores, M., Naya, S., Fernández-Casal, R., Zaragoza, S., Raña, P., Tarrío-Saavedra, J. (2020). Constructing control chart using functional data. Mathematics, 8, 58, DOI. Flores, M., Fernández-Casal, R., Naya, S., & Tarrío-Saavedra, J. (2021). Statistical Quality Control qcr Package. R Journal, 13, 194-217. DOI.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/archery1.html","id":null,"dir":"Reference","previous_headings":"","what":"Target archery dataset in the ranking round (used as Phase I) — archery1","title":"Target archery dataset in the ranking round (used as Phase I) — archery1","text":"consists stage archer shoots 72 arrows 12 ends six arrows.  information given x y coordinates.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/archery1.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Target archery dataset in the ranking round (used as Phase I) — archery1","text":"array (24 x 2 x 3). x-coordinate x-coordinate y-coordinate y-coordinate","code":""},{"path":"https://mflores72000.github.io/qcr/reference/archery1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Target archery dataset in the ranking round (used as Phase I) — archery1","text":"","code":"data(archery1) str(archery1) ; plot(archery1) #>  num [1:24, 1:2, 1:3] 24.14 28.55 3.97 28.57 -3.43 ... #>  - attr(*, \"dimnames\")=List of 3 #>   ..$ : NULL #>   ..$ : chr [1:2] \"x-coordinate\" \"y-coordinate\" #>   ..$ : NULL #>  - attr(*, \"names\")= chr [1:144] \"x-coordinate\" \"y-coordinate\" NA NA ..."},{"path":"https://mflores72000.github.io/qcr/reference/circuit.html","id":null,"dir":"Reference","previous_headings":"","what":"Circuit boards data — circuit","title":"Circuit boards data — circuit","text":"Number nonconformities observed 26 successive samples 100 printed circuit boards. Sample 6 20 control limits. Sample 6 examined new inspector recognize several type nonconformities present. Furthermore, unusually large number nonconformities sample 20 resulted temperature control problem wave soldering machine, subsequentely repaired. last 20 samples samples collected inspection units (formed 100 boards).","code":""},{"path":"https://mflores72000.github.io/qcr/reference/circuit.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Circuit boards data — circuit","text":"data frame 46 observations following 4 variables: x number defectives 100 printed circuit boards (inspection unit) sample sample ID size sample size trial trial sample indicator (TRUE/FALSE)","code":""},{"path":"https://mflores72000.github.io/qcr/reference/circuit.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Circuit boards data — circuit","text":"Montgomery, D.C. (1991) Introduction Statistical Quality Control, 2nd ed, New York, John Wiley & Sons, pp. 173--175","code":""},{"path":"https://mflores72000.github.io/qcr/reference/circuit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Circuit boards data — circuit","text":"","code":"data(circuit) attach(circuit) summary(circuit) #>        x             sample           size       trial         #>  Min.   : 5.00   Min.   : 1.00   Min.   :100   Mode :logical   #>  1st Qu.:16.00   1st Qu.:12.25   1st Qu.:100   FALSE:20        #>  Median :19.00   Median :23.50   Median :100   TRUE :26        #>  Mean   :19.17   Mean   :23.50   Mean   :100                   #>  3rd Qu.:22.00   3rd Qu.:34.75   3rd Qu.:100                   #>  Max.   :39.00   Max.   :46.00   Max.   :100                   boxplot(x ~ trial)  plot(x, type=\"b\")  detach(circuit)"},{"path":"https://mflores72000.github.io/qcr/reference/counters.html","id":null,"dir":"Reference","previous_headings":"","what":"The performance of the counters data — counters","title":"The performance of the counters data — counters","text":"water supply company wants control performance  water counters installed throughout city. purpose,  60 rational samples taken, one composed 3 measurements,  age (10 years) caliber water counters corresponding  two different brands, period 5 years. dataset based study case Coruña’s water supply company, Empresa  Municipal de Aguas de La Coruña (Emalcsa).","code":""},{"path":"https://mflores72000.github.io/qcr/reference/counters.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"The performance of the counters data — counters","text":"data frame 180 observations following 3 variables: error measurement error counters (Error:  (Real Volume - Measured Volume)/Real Volume) sample sample id brand brands providers counters","code":""},{"path":"https://mflores72000.github.io/qcr/reference/counters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The performance of the counters data — counters","text":"","code":"data(counters) attach(counters) summary(counters) #>      error               sample      brand  #>  Min.   :-0.001156   Min.   : 1.00   A:90   #>  1st Qu.: 0.001908   1st Qu.:15.75   B:90   #>  Median : 0.009774   Median :30.50          #>  Mean   : 0.027942   Mean   :30.50          #>  3rd Qu.: 0.035789   3rd Qu.:45.25          #>  Max.   : 0.150982   Max.   :60.00          plot(error, type=\"b\")  detach(counters)"},{"path":"https://mflores72000.github.io/qcr/reference/dowel1.html","id":null,"dir":"Reference","previous_headings":"","what":"Dowel pin dataset — dowel1","title":"Dowel pin dataset — dowel1","text":"Diameter length manufacturing process dowel pin.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/dowel1.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Dowel pin dataset — dowel1","text":"data frame 40 observations following 2 variables. diameter numeric vector length numeric vector","code":""},{"path":"https://mflores72000.github.io/qcr/reference/dowel1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dowel pin dataset — dowel1","text":"","code":"data(dowel1) str(dowel1) ; plot(dowel1) #> 'data.frame':\t40 obs. of  2 variables: #>  $ diameter: num  0.492 0.501 0.491 0.492 0.505 0.5 0.497 0.509 0.49 0.499 ... #>  $ length  : num  0.988 1.011 1.008 0.97 1.003 ..."},{"path":"https://mflores72000.github.io/qcr/reference/employment.html","id":null,"dir":"Reference","previous_headings":"","what":"Level of employment data — employment","title":"Level of employment data — employment","text":"Spaniard-Argentinian hotel company wants control  level occupancy (measured  application continuous control. purpose, 48 subsamples taken six hotels corresponding two different countries.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/employment.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Level of employment data — employment","text":"data frame 288 observations following 3 variables: occupantion amount occupants terms percentage sample sample id hemisphere Hemisphere","code":""},{"path":"https://mflores72000.github.io/qcr/reference/employment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Level of employment data — employment","text":"","code":"data(employment) attach(employment) summary(employment) #>   occupantion          sample      hemisphere #>  Min.   :  2.478   Min.   : 1.00   N:144      #>  1st Qu.: 48.046   1st Qu.:12.75   S:144      #>  Median : 63.376   Median :24.50              #>  Mean   : 62.748   Mean   :24.50              #>  3rd Qu.: 78.423   3rd Qu.:36.25              #>  Max.   :119.943   Max.   :48.00              boxplot(occupantion ~ hemisphere)  plot(occupantion, type=\"b\")  detach(employment)"},{"path":"https://mflores72000.github.io/qcr/reference/fdqcd.html","id":null,"dir":"Reference","previous_headings":"","what":"It creates a data object to be used in Functional Data Quality Control — fdqcd","title":"It creates a data object to be used in Functional Data Quality Control — fdqcd","text":"Create object class 'fdqcd' perform statistical quality control. object used plot Functional Data Control Charts.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/fdqcd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"It creates a data object to be used in Functional Data Quality Control — fdqcd","text":"","code":"fdqcd(x, data.name = NULL, ...)"},{"path":"https://mflores72000.github.io/qcr/reference/fdqcd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"It creates a data object to be used in Functional Data Quality Control — fdqcd","text":"x Matrix set cases dimension (n x m), n number curves  m points observed curve. data.name string specifies title displayed plots.  provided taken name object's data. ... arguments passed methods.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/fdqcd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"It creates a data object to be used in Functional Data Quality Control — fdqcd","text":"","code":"library(qcr) m <- 30 tt<-seq(0,1,len=m) mu<-30 * tt * (1 - tt)^(3/2) n0 <- 100 set.seed(12345) mdata<-matrix(NA,ncol=m,nrow=n0) sigma <- exp(-3*as.matrix(dist(tt))/0.9) for (i in 1:n0) mdata[i,]<- mu+0.5*mvrnorm(mu = mu,Sigma = sigma ) fdchart <- fdqcd(mdata) plot(fdchart,type=\"l\",col=\"gray\")"},{"path":"https://mflores72000.github.io/qcr/reference/fdqcs.depth.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot depth functional data (DFD) - chart — fdqcs.depth","title":"Function to plot depth functional data (DFD) - chart — fdqcs.depth","text":"function used compute statistics required DFD chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/fdqcs.depth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot depth functional data (DFD) - chart — fdqcs.depth","text":"","code":"fdqcs.depth(x, ...)  # S3 method for default fdqcs.depth(   x,   data.name = NULL,   func.depth = depth.mode,   nb = 200,   type = c(\"trim\", \"pond\"),   ns = 0.01,   plot = TRUE,   trim = 0.025,   smo = 0.05,   draw.control = NULL,   ... )  # S3 method for fdqcd fdqcs.depth(   x,   func.depth = depth.mode,   nb = 200,   type = c(\"trim\", \"pond\"),   ns = 0.01,   plot = TRUE,   trim = 0.025,   smo = 0.05,   draw.control = NULL,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/fdqcs.depth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot depth functional data (DFD) - chart — fdqcs.depth","text":"x R object (used select method). See details. ... arguments passed methods. data.name string specifies title displayed plots.  provided taken name object's data. func.depth Type depth measure, default depth.mode. nb number bootstrap samples. type method used trim data (trim pond). ns Quantile determine cutoff Bootstrap procedure plot logical value indicating plotted. trim porcentage trimming. smo smoothing parameter bootstrap samples. draw.control ist specifies col, lty lwd objects: fdataobj, statistic, .","code":""},{"path":"https://mflores72000.github.io/qcr/reference/fdqcs.depth.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Function to plot depth functional data (DFD) - chart — fdqcs.depth","text":"Flores, M.; Naya, S.; Fernández-Casal,R.; Zaragoza, S.; Raña, P.; Tarrío-Saavedra, J.  Constructing Control Chart Using Functional Data. Mathematics 2020, 8, 58.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/fdqcs.depth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot depth functional data (DFD) - chart — fdqcs.depth","text":"","code":"if (FALSE) { library(qcr) m <- 30 tt<-seq(0,1,len=m) mu<-30 * tt * (1 - tt)^(3/2) n0 <- 100 set.seed(12345) mdata<-matrix(NA,ncol=m,nrow=n0) sigma <- exp(-3*as.matrix(dist(tt))/0.9) for (i in 1:n0) mdata[i,]<- mu+0.5*mvrnorm(mu = mu,Sigma = sigma ) fdchart <- fdqcd(mdata) plot.fdqcd(fdchart,type=\"l\",col=\"gray\") set.seed(1234) fddep <- fdqcs.depth(fdchart,plot = T) plot(fddep,title.fdata = \"Fdata\",title.depth = \"Depth\") summary(fddep) }"},{"path":"https://mflores72000.github.io/qcr/reference/fdqcs.rank.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot rank functional data (DFD) - chart — fdqcs.rank","title":"Function to plot rank functional data (DFD) - chart — fdqcs.rank","text":"function used compute statistics required RFD chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/fdqcs.rank.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot rank functional data (DFD) - chart — fdqcs.rank","text":"","code":"fdqcs.rank(x, ...)  # S3 method for fdqcd fdqcs.rank(   x,   y = x,   func.depth = depth.FM,   alpha = 0.01,   plot = TRUE,   trim = 0.1,   draw.control = NULL,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/fdqcs.rank.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot rank functional data (DFD) - chart — fdqcs.rank","text":"x R object (used select method). See details. ... arguments passed methods. y set new curves evaluate depth. fdqcd class object. set reference curves respect depth computed. fdqcd class object. func.depth Type depth measure, default depth.mode. alpha Quantile determine cutoff Bootstrap procedure plot logical value indicating plotted. trim porcentage trimming. draw.control ist specifies col, lty lwd objects: fdataobj, statistic, .","code":""},{"path":"https://mflores72000.github.io/qcr/reference/fdqcs.rank.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Function to plot rank functional data (DFD) - chart — fdqcs.rank","text":"Flores, M.; Naya, S.; Fernández-Casal,R.; Zaragoza, S.; Raña, P.; Tarrío-Saavedra, J.  Constructing Control Chart Using Functional Data. Mathematics 2020, 8, 58.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/fdqcs.rank.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot rank functional data (DFD) - chart — fdqcs.rank","text":"","code":"if (FALSE) { library(qcr) m <- 30 tt<-seq(0,1,len=m) mu<-30 * tt * (1 - tt)^(3/2) n0 <- 100 set.seed(12345) mdata<-matrix(NA,ncol=m,nrow=n0) sigma <- exp(-3*as.matrix(dist(tt))/0.9) for (i in 1:n0) mdata[i,]<- mu+0.5*mvrnorm(mu = mu,Sigma = sigma ) fdchart <- fdqcd(mdata) summary(fdchart) plot(fdchart,type=\"l\",col=\"gray\") out <- fddep$out ## Outliers - State in Control alpha <- 0.005 trim <- 0.1 while (length(out)>0) {  mdata <- fddep$fdata$data[-out,]  fddep <- fdqcs.depth(mdata,ns = alpha, trim=trim, plot=FALSE)  out <- fddep$out } plot(fddep,title.fdata = \"FD-State in Control\",title.depth = \"Depth\") # Ha mu_a<- 30 * tt^(3/2) * (1 - tt) n_a <- 50 set.seed(12345) mdata_a<-matrix(NA,ncol=m,nrow=n_a) for (i in 1:n_a) mdata_a[i,]<- mu_a+0.5*mvrnorm(mu = mu_a,Sigma = sigma ) fdchart_a <- fdqcd(mdata_a,\"Curves Monitoring\") plot(fdchart_a) plot(fdchart,fdchart_a,main=\"Phase II\") pashe2.chart <- fdqcs.rank(fdchart,fdchart_a) plot(pashe2.chart,title.fdata = \"FDA\",title.rank = \"Rank\") summary(pashe2.chart) }"},{"path":"https://mflores72000.github.io/qcr/reference/mqcd.html","id":null,"dir":"Reference","previous_headings":"","what":"It creates a data object to be used in Multivariante Quality Control — mqcd","title":"It creates a data object to be used in Multivariante Quality Control — mqcd","text":"Create object class 'mqcd' perform statistical quality control. object used plot Multivariate Control Charts.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/mqcd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"It creates a data object to be used in Multivariante Quality Control — mqcd","text":"","code":"mqcd(data, data.name = NULL)"},{"path":"https://mflores72000.github.io/qcr/reference/mqcd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"It creates a data object to be used in Multivariante Quality Control — mqcd","text":"data matrix data-frame array contain data. data.name string specifies title displayed plots.  provided taken name object's data.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/mqcd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"It creates a data object to be used in Multivariante Quality Control — mqcd","text":"","code":"library(qcr) data(dowel1) str(dowel1) #> 'data.frame':\t40 obs. of  2 variables: #>  $ diameter: num  0.492 0.501 0.491 0.492 0.505 0.5 0.497 0.509 0.49 0.499 ... #>  $ length  : num  0.988 1.011 1.008 0.97 1.003 ... data.mqcd <- mqcd(dowel1) str(data.mqcd) #>  'mqcd' num [1:40, 1:2, 1] 0.492 0.501 0.491 0.492 0.505 0.5 0.497 0.509 0.49 0.499 ... #>  - attr(*, \"dimnames\")=List of 3 #>   ..$ : NULL #>   ..$ : chr [1:2] \"diameter\" \"length\" #>   ..$ : NULL #>  - attr(*, \"data.name\")= chr \" DATA\" #>  - attr(*, \"type.data\")= chr \"Multivariate\""},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.add.html","id":null,"dir":"Reference","previous_headings":"","what":"mqcs.add Add a matrix, data.frame or array object with a mqcs object — mqcs.add","title":"mqcs.add Add a matrix, data.frame or array object with a mqcs object — mqcs.add","text":"function used join two objects type matrix, data.frame array mqcs.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.add.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mqcs.add Add a matrix, data.frame or array object with a mqcs object — mqcs.add","text":"","code":"mqcs.add(x, ...)  # S3 method for default mqcs.add(x, value, ...)"},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.add.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"mqcs.add Add a matrix, data.frame or array object with a mqcs object — mqcs.add","text":"x Object type mqcs ... arguments passed methods. value Object type data.frame, matrix array","code":""},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.html","id":null,"dir":"Reference","previous_headings":"","what":"It computes statistics to be used in Multivariante Quality Control — mqcs","title":"It computes statistics to be used in Multivariante Quality Control — mqcs","text":"Create object class 'mqcs' perform statistical quality control. function used compute statistics required plot Multivariate Control Charts","code":""},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"It computes statistics to be used in Multivariante Quality Control — mqcs","text":"","code":"mqcs(x, method = \"sw\", ...)"},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"It computes statistics to be used in Multivariante Quality Control — mqcs","text":"x Object mqcd (Multivariante Quality Control Data) method method employed compute covatiance matrix individual observation case. Two methods used \"sw\"  compute according (Sullivan,Woodall 1996a) \"hm\"  (Holmes,Mergen 1993) ... arguments passed methods.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.mcusum.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot mcusum chart — mqcs.mcusum","title":"Function to plot mcusum chart — mqcs.mcusum","text":"function used compute statistics required mcusum chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.mcusum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot mcusum chart — mqcs.mcusum","text":"","code":"mqcs.mcusum(x, ...)  # S3 method for default mqcs.mcusum(   x,   data.name = NULL,   limits = NULL,   Xmv = NULL,   S = NULL,   k = 0.5,   h = 5.5,   method = \"sw\",   plot = FALSE,   ... )  # S3 method for mqcd mqcs.mcusum(   x,   limits = NULL,   Xmv = NULL,   S = NULL,   k = 0.5,   h = 5.5,   method = \"sw\",   plot = FALSE,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.mcusum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot mcusum chart — mqcs.mcusum","text":"x R object (used select method). See details. ... arguments passed methods. data.name string specifies title displayed plots.  provided taken name object's data. limits two-values vector specifying control limits. Xmv mean vector. specified Phase II parameters distribution known. S sample covariance matrix. used Phase II parameters distribution known. k constant used MCUSUM chart. Frequently k = 0.5 h constant used MCUSUM chart. Usually h = 5.5 method method employed compute covatiance matrix individual observation case. Two methods used \"sw\"  compute according (Sullivan,Woodall 1996a) \"hm\"  (Holmes,Mergen 1993) plot logical value indicating plotted.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.mcusum.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to plot mcusum chart — mqcs.mcusum","text":"Edgar Santos-Fernandez","code":""},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.mcusum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot mcusum chart — mqcs.mcusum","text":"","code":"## ##  Continuous data  ## library(qcr) data(dowel1) str(dowel1) #> 'data.frame':\t40 obs. of  2 variables: #>  $ diameter: num  0.492 0.501 0.491 0.492 0.505 0.5 0.497 0.509 0.49 0.499 ... #>  $ length  : num  0.988 1.011 1.008 0.97 1.003 ... data.mqcd <- mqcd(dowel1) res.mqcs <- mqcs.mcusum(data.mqcd) summary(res.mqcs) #>  #> Summary of group statistics: #>        V1         #>  Min.   :0.0000   #>  1st Qu.:0.7749   #>  Median :1.1501   #>  Mean   :1.3818   #>  3rd Qu.:1.9987   #>  Max.   :3.8409   #>  #> Number of quality characteristics:  2 #> Number of samples or observations:  40 #> Number of observations or sample size:  1 #>  #> Mean Vector:  #>  0.500875 1.001825 #> Covariance Matrix: #>          diameter       length #> [1,] 4.908654e-05 8.584936e-05 #> [2,] 8.584936e-05 4.199429e-04 #>  #> Control limits:  #> lcl ucl  #> 0.0 5.5  #>  #> Number beyond limits: 0  plot(res.mqcs, title =\" MCUSUM Control Chart for dowel1\")"},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.mewma.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot mewma chart — mqcs.mewma","title":"Function to plot mewma chart — mqcs.mewma","text":"function used compute statistics required mewma chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.mewma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot mewma chart — mqcs.mewma","text":"","code":"mqcs.mewma(x, ...)  # S3 method for default mqcs.mewma(   x,   data.name = NULL,   limits = NULL,   Xmv = NULL,   S = NULL,   method = \"sw\",   plot = FALSE,   ... )  # S3 method for mqcd mqcs.mewma(   x,   limits = NULL,   Xmv = NULL,   S = NULL,   lambda = 0.1,   method = \"sw\",   plot = FALSE,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.mewma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot mewma chart — mqcs.mewma","text":"x R object (used select method). See details. ... arguments passed methods. data.name string specifies title displayed plots.  provided taken name object's data. limits two-values vector specifying control limits. Xmv mean vector. specified Phase II parameters distribution known. S sample covariance matrix. used Phase II parameters distribution known. method method employed compute covatiance matrix individual observation case. Two methods used \"sw\"  compute according (Sullivan,Woodall 1996a) \"hm\"  (Holmes,Mergen 1993) plot logical value indicating plotted. lambda smoothing constant. values 0.1, 0.2,...,0.9 allowed.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.mewma.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to plot mewma chart — mqcs.mewma","text":"Edgar Santos-Fernandez","code":""},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.mewma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot mewma chart — mqcs.mewma","text":"","code":"## ##  Continuous data  ## library(qcr) data(dowel1) str(dowel1) #> 'data.frame':\t40 obs. of  2 variables: #>  $ diameter: num  0.492 0.501 0.491 0.492 0.505 0.5 0.497 0.509 0.49 0.499 ... #>  $ length  : num  0.988 1.011 1.008 0.97 1.003 ... data.mqcd <- mqcd(dowel1) res.mqcs <- mqcs.mewma(data.mqcd) summary(res.mqcs) #>  #> Summary of group statistics: #>        V1          #>  Min.   :0.04165   #>  1st Qu.:0.95586   #>  Median :1.69276   #>  Mean   :1.62204   #>  3rd Qu.:1.89606   #>  Max.   :4.17595   #>  #> Number of quality characteristics:  2 #> Number of samples or observations:  40 #> Number of observations or sample size:  1 #>  #> Mean Vector:  #>  0.500875 1.001825 #> Covariance Matrix: #>          diameter       length #> [1,] 4.908654e-05 8.584936e-05 #> [2,] 8.584936e-05 4.199429e-04 #>  #> Control limits:  #>    lcl    ucl  #> 0.0000 8.6336  #>  #> Number beyond limits: 0  plot(res.mqcs, title =\" MEWMA Control Chart for dowel1\")"},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.t2.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot t2 Hotelling chart — mqcs.t2","title":"Function to plot t2 Hotelling chart — mqcs.t2","text":"function used compute statistics required t2 chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.t2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot t2 Hotelling chart — mqcs.t2","text":"","code":"mqcs.t2(x, ...)  # S3 method for default mqcs.t2(   x,   data.name = NULL,   limits = NULL,   Xmv = NULL,   S = NULL,   colm = NULL,   alpha = 0.01,   phase = 1,   method = \"sw\",   plot = FALSE,   ... )  # S3 method for mqcd mqcs.t2(   x,   limits = NULL,   Xmv = NULL,   S = NULL,   colm = NULL,   alpha = 0.01,   phase = 1,   method = \"sw\",   plot = FALSE,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.t2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot t2 Hotelling chart — mqcs.t2","text":"x R object (used select method). See details. ... arguments passed methods. data.name string specifies title displayed plots.  provided taken name object's data. limits two-values vector specifying control limits. Xmv mean vector. specified Phase II parameters distribution known. S sample covariance matrix. used Phase II parameters distribution known. colm number samples (m) used Hotelling control chart Phase II alpha significance level (0.01 default) phase Allows select type UCL use. values phase = 1 2 allowed. method method employed compute covatiance matrix individual observation case. Two methods used \"sw\"  compute according (Sullivan,Woodall 1996a) \"hm\"  (Holmes,Mergen 1993) plot logical value indicating plotted.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.t2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to plot t2 Hotelling chart — mqcs.t2","text":"Edgar Santos-Fernandez","code":""},{"path":"https://mflores72000.github.io/qcr/reference/mqcs.t2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot t2 Hotelling chart — mqcs.t2","text":"","code":"## ##  Continuous data  ## library(qcr) data(dowel1) str(dowel1) #> 'data.frame':\t40 obs. of  2 variables: #>  $ diameter: num  0.492 0.501 0.491 0.492 0.505 0.5 0.497 0.509 0.49 0.499 ... #>  $ length  : num  0.988 1.011 1.008 0.97 1.003 ... data.mqcd <- mqcd(dowel1) res.mqcs <- mqcs.t2(data.mqcd) summary(res.mqcs) #>  #> Summary of group statistics: #>        V1          #>  Min.   :0.09137   #>  1st Qu.:0.60154   #>  Median :1.66096   #>  Mean   :1.95000   #>  3rd Qu.:2.64402   #>  Max.   :5.34020   #>  #> Number of quality characteristics:  2 #> Number of samples or observations:  40 #> Number of observations or sample size:  1 #>  #> Mean Vector:  #>  0.500875 1.001825 #> Covariance Matrix: #>          diameter       length #> [1,] 4.908654e-05 8.584936e-05 #> [2,] 8.584936e-05 4.199429e-04 #>  #> Control limits:  #>      lcl      ucl  #>  0.00000 12.44888  #>  #> Number beyond limits: 0  plot(res.mqcs, title =\" Hotelling Control Chart for dowel1\")   data(archery1) str(archery1) #>  num [1:24, 1:2, 1:3] 24.14 28.55 3.97 28.57 -3.43 ... #>  - attr(*, \"dimnames\")=List of 3 #>   ..$ : NULL #>   ..$ : chr [1:2] \"x-coordinate\" \"y-coordinate\" #>   ..$ : NULL #>  - attr(*, \"names\")= chr [1:144] \"x-coordinate\" \"y-coordinate\" NA NA ... data.mqcd <- mqcd(archery1) res.mqcs <- mqcs.t2(data.mqcd) summary(res.mqcs) #>  #> Summary of group statistics: #>        V1          #>  Min.   :0.04769   #>  1st Qu.:0.37341   #>  Median :0.92883   #>  Mean   :1.51997   #>  3rd Qu.:2.11386   #>  Max.   :6.16892   #>  #> Number of quality characteristics:  2 #> Number of samples or observations:  24 #> Number of observations or sample size:  3 #>  #> Mean Vector:  #>  6.779028 5.772917 #> Covariance Matrix: #>           [,1]      [,2] #> [1,] 105.25999  48.44271 #> [2,]  48.44271 149.28805 #>  #> Control limits:  #>      lcl      ucl  #> 0.000000 9.958262  #>  #> Number beyond limits: 0  plot(res.mqcs, title =\" Hotelling Control Chart for archery1\")"},{"path":"https://mflores72000.github.io/qcr/reference/mstate.control.html","id":null,"dir":"Reference","previous_headings":"","what":"Multivariate process state — mstate.control","title":"Multivariate process state — mstate.control","text":"function removes observations sample violates  rules process control","code":""},{"path":"https://mflores72000.github.io/qcr/reference/mstate.control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multivariate process state — mstate.control","text":"","code":"mstate.control(x)"},{"path":"https://mflores72000.github.io/qcr/reference/mstate.control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multivariate process state — mstate.control","text":"x Object mqcd (Multivariate Quality Control Statistical) control logical value indicating whether initial sample comes process control.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/mstate.control.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multivariate process state — mstate.control","text":"","code":"## ##  Continuous data  ## library(qcr) set.seed(356) x <- matrix(rnorm(66),ncol=3) x <- rbind(x,matrix(rexp(66,100),ncol=3)) dim(x) #> [1] 44  3 x <-mqcd(x) str(x) #>  'mqcd' num [1:44, 1:3, 1] 0.306 -1.179 -0.322 -0.258 1.389 ... #>  - attr(*, \"data.name\")= chr \" DATA\" #>  - attr(*, \"type.data\")= chr \"Multivariate\" x <-mqcs.mewma(x) str(x) #> List of 9 #>  $ mqcd      : 'mqcd' num [1:44, 1:3, 1] 0.306 -1.179 -0.322 -0.258 1.389 ... #>   ..- attr(*, \"data.name\")= chr \" DATA\" #>   ..- attr(*, \"type.data\")= chr \"Multivariate\" #>  $ type      : chr \"mewma\" #>  $ statistics: num [1:44, 1] 13.9 14.6 10.1 15 14.1 ... #>  $ mean      : num [1:3] 0.1665 0.0843 0.3165 #>  $ S         : num [1:3, 1:3] 0.6165 0.0546 0.0468 0.0546 0.6994 ... #>  $ lambda    : num 0.1 #>  $ limits    : Named num [1:2] 0 10.8 #>   ..- attr(*, \"names\")= chr [1:2] \"lcl\" \"ucl\" #>  $ data.name : chr \" DATA\" #>  $ violations: int [1:5] 1 2 4 5 19 #>  - attr(*, \"class\")= chr [1:2] \"mqcs.mewma\" \"mqcs\" plot(x)  data.mqcs <- mstate.control(x) x <-mqcs.mewma(data.mqcs) plot(x)"},{"path":"https://mflores72000.github.io/qcr/reference/npqcd.html","id":null,"dir":"Reference","previous_headings":"","what":"It creates a data object for Non Parametric Quality Control — npqcd","title":"It creates a data object for Non Parametric Quality Control — npqcd","text":"creates object class 'npqcd' perform statistical quality control. object used plot Non Parametric Multivariate Control Charts.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/npqcd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"It creates a data object for Non Parametric Quality Control — npqcd","text":"","code":"npqcd(x, G = NULL, data.name = NULL)"},{"path":"https://mflores72000.github.io/qcr/reference/npqcd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"It creates a data object for Non Parametric Quality Control — npqcd","text":"x matrix data-frame array contain data.  Dimension observations. G x matrix, data frame list. matrix data frame, row viewed one multivariate observation. data.name string specifies title displayed plots.  provided taken name object x.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/npqcd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"It creates a data object for Non Parametric Quality Control — npqcd","text":"","code":"library(qcr)  set.seed(356) data <- matrix(rnorm(999), nc = 3) x <-rexp(999,0.5)  x <-matrix(x,ncol=3)  data.npqcd <- npqcd(data,x) str(data.npqcd) #> List of 2 #>  $ x: num [1:333, 1:3, 1] 0.306 -1.179 -0.322 -0.258 1.389 ... #>  $ G: num [1:333, 1:3] 1.75 1.47 5.4 0.97 1.55 ... #>  - attr(*, \"data.name\")= chr \"DATA\" #>  - attr(*, \"type.data\")= chr \"Multivariate\" #>  - attr(*, \"class\")= chr [1:2] \"npqcd\" \"list\""},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.add.html","id":null,"dir":"Reference","previous_headings":"","what":"npqcs.add Add a matrix, data.frame or array object with a npqcs object — npqcs.add","title":"npqcs.add Add a matrix, data.frame or array object with a npqcs object — npqcs.add","text":"function used join two objects type matrix, data.frame array npqcs.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.add.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"npqcs.add Add a matrix, data.frame or array object with a npqcs object — npqcs.add","text":"","code":"npqcs.add(x, ...)  # S3 method for default npqcs.add(x, value, ...)"},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.add.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"npqcs.add Add a matrix, data.frame or array object with a npqcs object — npqcs.add","text":"x Object type npqcs ... arguments passed methods. value Object type data.frame, matrix array","code":""},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.html","id":null,"dir":"Reference","previous_headings":"","what":"Statistical Quality Control Object — npqcs","title":"Statistical Quality Control Object — npqcs","text":"Create object class 'npqcs' perform statistical quality control. function used compute statistics required plot  Non Parametric Multivariate Control Charts.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Statistical Quality Control Object — npqcs","text":"","code":"npqcs(x, method = c(\"Tukey\", \"Liu\", \"Mahalanobis\", \"RP\", \"LD\"), ...)"},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Statistical Quality Control Object — npqcs","text":"x Object npqcd (Non Parametric Multivariante Quality Control Data) method Character string determines depth function used.  method can \"Tukey\" (default), \"Liu\", \"Mahalanobis\", \"RP\" Random Project \"LD\" Likelihood depth. ... Arguments passed methods.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.Q.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot the Q chart — npqcs.Q","title":"Function to plot the Q chart — npqcs.Q","text":"function used compute statistics required Q chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.Q.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot the Q chart — npqcs.Q","text":"","code":"npqcs.Q(x, ...)  # S3 method for default npqcs.Q(   x,   G,   data.name = NULL,   limits = NULL,   method = c(\"Tukey\", \"Liu\", \"Mahalanobis\", \"RP\", \"LD\"),   alpha = 0.01,   plot = FALSE,   ... )  # S3 method for npqcd npqcs.Q(   x,   data.name,   limits = NULL,   method = c(\"Tukey\", \"Liu\", \"Mahalanobis\", \"RP\", \"LD\"),   alpha = 0.01,   plot = FALSE,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.Q.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot the Q chart — npqcs.Q","text":"x object npqcd (Non parametric Quality Control Data) ... Arguments passed methods. G x matrix, data frame list. matrix data frame, row viewed one multivariate observation. data.name string specifies title displayed plots.  provided taken name object x. limits two-value vector specifying control limits lower central. method Character string determines depth function used.  method can \"Tukey\" (default), \"Liu\", \"Mahalanobis\", \"RP\" Random Project \"LD\" Likelihood depth. alpha significance level (0.01 default) plot Logical value. TRUE Q chart plotted.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.Q.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Function to plot the Q chart — npqcs.Q","text":"Regina Liu (1995)","code":""},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.Q.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot the Q chart — npqcs.Q","text":"","code":"if (FALSE) {  ## ##  Continuous data  ## library(qcr) set.seed(12345) mu<-c(0,0) Sigma<- matrix(c(1,0,0,1),nrow = 2,ncol = 2) u <- c(2,2) S <- matrix(c(4,0,0,4),nrow = 2,ncol = 2) G <- rmvnorm(540, mean = mu, sigma = Sigma) x<- rmvnorm(40,mean=u,sigma = S) x <- rbind(G[501:540,],x) n <- 4 # samples m <- 20  # measurements k <- 2  # number of variables x.a <- array(,dim=c(n,k,m)) for (i in 1:m){ x.a[,,i] <- x[(1+(i-1)*n):(i*n),] } M <- G[1:500,] data.npqcd <- npqcd(x.a,M) str(data.npqcd) res.npqcs <- npqcs.Q(data.npqcd,method = \"Liu\", alpha=0.025) str(res.npqcs) summary(res.npqcs) plot(res.npqcs,title =\" Q Control Chart\")}"},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.r.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot the r chart — npqcs.r","title":"Function to plot the r chart — npqcs.r","text":"function used compute statistics required r chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot the r chart — npqcs.r","text":"","code":"npqcs.r(x, ...)  # S3 method for default npqcs.r(   x,   G,   data.name = NULL,   limits = NULL,   method = c(\"Tukey\", \"Liu\", \"Mahalanobis\", \"RP\", \"LD\"),   alpha = 0.01,   plot = FALSE,   ... )  # S3 method for npqcd npqcs.r(   x,   data.name,   limits = NULL,   method = c(\"Tukey\", \"Liu\", \"Mahalanobis\", \"RP\", \"LD\"),   alpha = 0.01,   plot = FALSE,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.r.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot the r chart — npqcs.r","text":"x object npqcd (Non parametric Quality Control Data) ... Arguments passed methods. G x matrix, data frame list. matrix data frame, row viewed one multivariate observation. data.name string specifies title displayed plots.  provided taken name object x. limits two-value vector specifying control limits lower central. method Character string determines depth function used.  method can \"Tukey\" (default), \"Liu\", \"Mahalanobis\", \"RP\" Random Project \"LD\" Likelihood depth. alpha significance level (0.01 default) plot Logical value. TRUE r chart plotted.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.r.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Function to plot the r chart — npqcs.r","text":"Regina Liu (1995)","code":""},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.r.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot the r chart — npqcs.r","text":"","code":"if (FALSE) { library(qcr) set.seed(356) mu<-c(0,0) Sigma<- matrix(c(1,0,0,1),nrow = 2,ncol = 2) u <- c(2,2) S <- matrix(c(4,0,0,4),nrow = 2,ncol = 2) G <- rmvnorm(540, mean = mu, sigma = Sigma) x<- rmvnorm(40,mean=u,sigma = S) x <- rbind(G[501:540,],x) M <- G[1:500,] data.npqcd <- npqcd(x,M) str(data.npqcd) res.npqcs <- npqcs.r(data.npqcd,method = \"Liu\", alpha=0.025) str(res.npqcs) summary(res.npqcs) plot(res.npqcs,title =\" r Control Chart\")  }"},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.S.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot the S chart — npqcs.S","title":"Function to plot the S chart — npqcs.S","text":"function used compute statistics required S chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.S.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot the S chart — npqcs.S","text":"","code":"npqcs.S(x, ...)  # S3 method for default npqcs.S(   x,   G,   data.name = NULL,   limits = NULL,   method = c(\"Tukey\", \"Liu\", \"Mahalanobis\", \"RP\", \"LD\"),   alpha = 0.01,   plot = FALSE,   standardize = FALSE,   ... )  # S3 method for npqcd npqcs.S(   x,   data.name,   limits = NULL,   method = c(\"Tukey\", \"Liu\", \"Mahalanobis\", \"RP\", \"LD\"),   alpha = 0.01,   plot = FALSE,   standardize = F,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.S.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot the S chart — npqcs.S","text":"x object npqcd (Non parametric Quality Control Data) ... Arguments passed methods. G x matrix, data frame list. matrix data frame, row viewed one multivariate observation. data.name string specifies title displayed plots.  provided taken name object x. limits two-value vector specifying control limits lower central. method Character string determines depth function used.  method can \"Tukey\" (default), \"Liu\", \"Mahalanobis\", \"RP\" Random Project \"LD\" Likelihood depth. alpha significance level (0.01 default) plot Logical value. TRUE S chart plotted. standardize logical value indicating data standardized.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.S.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Function to plot the S chart — npqcs.S","text":"Regina Liu (1995)","code":""},{"path":"https://mflores72000.github.io/qcr/reference/npqcs.S.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot the S chart — npqcs.S","text":"","code":"if (FALSE) { ## ##  Continuous data  ## set.seed(12345) mu<-c(0,0) Sigma<- matrix(c(1,0,0,1),nrow = 2,ncol = 2) u <- c(2,2) S <- matrix(c(4,0,0,4),nrow = 2,ncol = 2) G <- rmvnorm(540, mean = mu, sigma = Sigma) x<- rmvnorm(40,mean=u,sigma = S) x.a <- rbind(G[501:540,],x) M <- G[1:500,] data.npqcd <- npqcd(x.a,M) res.npqcs <- npqcs.S(data.npqcd,method = \"Liu\", alpha=0.05) summary(res.npqcs) plot(res.npqcs,title =\" S Control Chart\")}"},{"path":"https://mflores72000.github.io/qcr/reference/npstate.control.html","id":null,"dir":"Reference","previous_headings":"","what":"non parametric process state — npstate.control","title":"non parametric process state — npstate.control","text":"function removes observations sample violates  rules process control","code":""},{"path":"https://mflores72000.github.io/qcr/reference/npstate.control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"non parametric process state — npstate.control","text":"","code":"npstate.control(x, control = FALSE)"},{"path":"https://mflores72000.github.io/qcr/reference/npstate.control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"non parametric process state — npstate.control","text":"x Object npqcd (Quality Control Statitical Non Parametric) control logical value indicating whether initial sample comes process control.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/npstate.control.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"non parametric process state — npstate.control","text":"","code":"if (FALSE) { ## ##  Continuous data  ## library(qcr) set.seed(356) mu<-c(0,0) Sigma<- matrix(c(1,0,0,1),nrow = 2,ncol = 2) mu <- c(2,2) S <- matrix(c(4,0,0,4),nrow = 2,ncol = 2) G <- rmvnorm(540, mean = mu, sigma = Sigma) x<- rmvnorm(40,mean=mu,sigma = S) x <- rbind(G[501:540,],x) M <- G[1:500,] data.npqcd <- npqcd(x,M) str(data.npqcd) res.npqcs <- npqcs.r(data.npqcd,method = \"Liu\", alpha=0.025) str(res.npqcs) summary(res.npqcs) plot(res.npqcs) new.npqcd <- npstate.control(x = res.npqcs) res.npqcs <- npqcs.r(new.npqcd) summary(res.npqcs) plot(res.npqcs)   }"},{"path":"https://mflores72000.github.io/qcr/reference/orangejuice.html","id":null,"dir":"Reference","previous_headings":"","what":"Orange juice data — orangejuice","title":"Orange juice data — orangejuice","text":"Frozen orange juice concentrate packed 6-oz cardboard cans. cans formed machine spinning cardboard stock attaching metal bottom panel. can inspected determine whether, filled, liquid possible leak either side seam around bottom joint. occurs can considered nonconforming. data collected 30 samples 50 cans half-hour intervals three-shift period machine continuous operation. sample 15 used, new bacth cardboard stock punt production. Sample 23 obtained inexperienced operator temporarily assigned machine. first 30 samples, machine adjustment made. 24 samples taken process.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/orangejuice.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Orange juice data — orangejuice","text":"data frame 54 observations following 4 variables: sample sample id D number defectives size sample sizes trial trial samples (TRUE/FALSE)","code":""},{"path":"https://mflores72000.github.io/qcr/reference/orangejuice.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Orange juice data — orangejuice","text":"Montgomery, D.C. (1991) Introduction Statistical Quality Control, 2nd ed, New York, John Wiley & Sons, pp. 152--155.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/orangejuice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Orange juice data — orangejuice","text":"","code":"data(orangejuice) orangejuice$d <- orangejuice$D/orangejuice$size attach(orangejuice) summary(orangejuice) #>        D              sample           size      trial               d          #>  Min.   : 2.000   Min.   : 1.00   Min.   :50   Mode :logical   Min.   :0.0400   #>  1st Qu.: 5.000   1st Qu.:14.25   1st Qu.:50   FALSE:24        1st Qu.:0.1000   #>  Median : 7.000   Median :27.50   Median :50   TRUE :30        Median :0.1400   #>  Mean   : 8.889   Mean   :27.50   Mean   :50                   Mean   :0.1778   #>  3rd Qu.:12.000   3rd Qu.:40.75   3rd Qu.:50                   3rd Qu.:0.2400   #>  Max.   :24.000   Max.   :54.00   Max.   :50                   Max.   :0.4800   boxplot(d ~ trial)  mark <- ifelse(trial, 1, 2) plot(sample, d, type=\"b\", col=mark, pch=mark)"},{"path":"https://mflores72000.github.io/qcr/reference/oxidation.html","id":null,"dir":"Reference","previous_headings":"","what":"Oxidation Onset Temperature — oxidation","title":"Oxidation Onset Temperature — oxidation","text":"database contains information level purity  batch Picual varities. type oil  measuring Oxidation Onset Temperature.  50 subsamples oil temperature oxide.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/oxidation.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Oxidation Onset Temperature — oxidation","text":"data frame 250 observations following 2 variables: OOT quantitative variable controls quality oil. sample sample id","code":""},{"path":"https://mflores72000.github.io/qcr/reference/oxidation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Oxidation Onset Temperature — oxidation","text":"","code":"data(oxidation) attach(oxidation) #> The following object is masked from orangejuice: #>  #>     sample summary(oxidation) #>       OOT            sample     #>  Min.   :103.3   Min.   : 1.0   #>  1st Qu.:143.7   1st Qu.:13.0   #>  Median :162.1   Median :25.5   #>  Mean   :160.4   Mean   :25.5   #>  3rd Qu.:178.0   3rd Qu.:38.0   #>  Max.   :221.3   Max.   :50.0   plot(OOT, type=\"b\")  detach(oxidation)"},{"path":"https://mflores72000.github.io/qcr/reference/pcmanufact.html","id":null,"dir":"Reference","previous_headings":"","what":"Personal computer manufacturer data — pcmanufact","title":"Personal computer manufacturer data — pcmanufact","text":"personal computer manufacturer counts number nonconformities per unit final assembly line. collects data 20 samples 5 computers .","code":""},{"path":"https://mflores72000.github.io/qcr/reference/pcmanufact.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Personal computer manufacturer data — pcmanufact","text":"data frame 10 observations following 2 variables. x number nonconformities (inspection units) sample sample ID size number computers inspected","code":""},{"path":"https://mflores72000.github.io/qcr/reference/pcmanufact.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Personal computer manufacturer data — pcmanufact","text":"Montgomery, D.C. (1991) Introduction Statistical Quality Control, 2nd ed, New York, John Wiley & Sons, pp. 181--182","code":""},{"path":"https://mflores72000.github.io/qcr/reference/pcmanufact.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Personal computer manufacturer data — pcmanufact","text":"","code":"data(pcmanufact) summary(pcmanufact) #>        x             sample           size   #>  Min.   : 5.00   Min.   : 1.00   Min.   :5   #>  1st Qu.: 7.00   1st Qu.: 5.75   1st Qu.:5   #>  Median :10.00   Median :10.50   Median :5   #>  Mean   : 9.65   Mean   :10.50   Mean   :5   #>  3rd Qu.:11.25   3rd Qu.:15.25   3rd Qu.:5   #>  Max.   :16.00   Max.   :20.00   Max.   :5   plot(pcmanufact$x/pcmanufact$size, type=\"b\")"},{"path":"https://mflores72000.github.io/qcr/reference/pistonrings.html","id":null,"dir":"Reference","previous_headings":"","what":"Piston rings data — pistonrings","title":"Piston rings data — pistonrings","text":"Piston rings automotive engine produced forging process. inside diameter rings manufactured process measured 25 samples, size 5, drawn process considered 'control'.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/pistonrings.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Piston rings data — pistonrings","text":"data frame 200 observations following 3 variables. diameter numeric vector sample sample ID trial trial sample indicator (TRUE/FALSE)","code":""},{"path":"https://mflores72000.github.io/qcr/reference/pistonrings.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Piston rings data — pistonrings","text":"Montgomery, D.C. (1991) Introduction Statistical Quality Control, 2nd ed, New York, John Wiley & Sons, pp. 206--213","code":""},{"path":"https://mflores72000.github.io/qcr/reference/pistonrings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Piston rings data — pistonrings","text":"","code":"data(pistonrings) attach(pistonrings) #> The following objects are masked from orangejuice: #>  #>     sample, trial summary(pistonrings) #>     diameter         sample        trial         #>  Min.   :73.97   Min.   : 1.00   Mode :logical   #>  1st Qu.:74.00   1st Qu.:10.75   FALSE:75        #>  Median :74.00   Median :20.50   TRUE :125       #>  Mean   :74.00   Mean   :20.50                   #>  3rd Qu.:74.01   3rd Qu.:30.25                   #>  Max.   :74.04   Max.   :40.00                   boxplot(diameter ~ sample)  plot(sample, diameter, cex=0.7) lines(tapply(diameter,sample,mean))  detach(pistonrings)"},{"path":"https://mflores72000.github.io/qcr/reference/plates.html","id":null,"dir":"Reference","previous_headings":"","what":"Vickers hardness data — plates","title":"Vickers hardness data — plates","text":"known chemical company developing patent  new variant artificial stone composed mostly quartz ( 93wt  polyester resin . company launching pilot plant  begins produce plates material industry scale. order  measure degree product homogeneity, 50 samples taken,  performed 5 measurements per plate corresponding different areas  artificial stone Vickers hardness","code":""},{"path":"https://mflores72000.github.io/qcr/reference/plates.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Vickers hardness data — plates","text":"data frame 250 observations following 2 variables: hardness Vickers hardness corresponding different    areas artificial stone sample sample id","code":""},{"path":"https://mflores72000.github.io/qcr/reference/plates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vickers hardness data — plates","text":"","code":"data(plates) attach(plates) #> The following object is masked from orangejuice: #>  #>     sample summary(plates) #>     hardness          sample     #>  Min.   : 55.98   Min.   : 1.0   #>  1st Qu.:180.29   1st Qu.:13.0   #>  Median :195.30   Median :25.5   #>  Mean   :192.05   Mean   :25.5   #>  3rd Qu.:204.75   3rd Qu.:38.0   #>  Max.   :242.69   Max.   :50.0   plot(hardness, type=\"b\")  detach(plates)"},{"path":"https://mflores72000.github.io/qcr/reference/plot.fdqcd.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for 'fdqcd' objects — plot.fdqcd","title":"Plot method for 'fdqcd' objects — plot.fdqcd","text":"Generic function plotting Multivarite charts object class 'fdqcd' perform statistical  quality control.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/plot.fdqcd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for 'fdqcd' objects — plot.fdqcd","text":"","code":"# S3 method for fdqcd plot(x, y = NULL, title = NULL, xlab = NULL, ylab = NULL, col = NULL, ...)"},{"path":"https://mflores72000.github.io/qcr/reference/plot.fdqcd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for 'fdqcd' objects — plot.fdqcd","text":"x Object fdqcd (pashe ) y Object fdqcd (monitoring) title overall title plot xlab title x axis ylab title y axis col color curves ... arguments passed methods.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/plot.fdqcd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot method for 'fdqcd' objects — plot.fdqcd","text":"","code":"library(qcr) m <- 30 tt<-seq(0,1,len=m) mu<-30 * tt * (1 - tt)^(3/2) n0 <- 100 set.seed(12345) mdata<-matrix(NA,ncol=m,nrow=n0) sigma <- exp(-3*as.matrix(dist(tt))/0.9) for (i in 1:n0) mdata[i,]<- mu+0.5*mvrnorm(mu = mu,Sigma = sigma ) fdchart <- fdqcd(mdata) plot(fdchart,type=\"l\",col=\"gray\")"},{"path":"https://mflores72000.github.io/qcr/reference/plot.fdqcs.depth.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for 'fdqcs.depth' objects — plot.fdqcs.depth","title":"Plot method for 'fdqcs.depth' objects — plot.fdqcs.depth","text":"Generic function plotting charts object class 'fdqcs.depth' perform statistical  quality control.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/plot.fdqcs.depth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for 'fdqcs.depth' objects — plot.fdqcs.depth","text":"","code":"# S3 method for fdqcs.depth plot(   x,   title.fdata = NULL,   title.depth = NULL,   xlab = NULL,   ylab = NULL,   col = NULL,   draw.control = NULL,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/plot.fdqcs.depth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for 'fdqcs.depth' objects — plot.fdqcs.depth","text":"x Object fdqcs.depth title.fdata overall title fdata plot title.depth overall title depth plot xlab title x axis ylab title y axis col color curves draw.control ist specifies col, lty lwd objects: fdataobj, statistic, . ... arguments passed methods.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/plot.fdqcs.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for 'fdqcs.depth' objects — plot.fdqcs.depth","title":"Plot method for 'fdqcs.depth' objects — plot.fdqcs.depth","text":"Generic function plotting charts object class 'fdqcs.depth' perform statistical  quality control.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/plot.fdqcs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for 'fdqcs.depth' objects — plot.fdqcs.depth","text":"","code":"# S3 method for fdqcs.depth plot(   x,   title.fdata = NULL,   title.depth = NULL,   xlab = NULL,   ylab = NULL,   col = NULL,   draw.control = NULL,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/plot.fdqcs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for 'fdqcs.depth' objects — plot.fdqcs.depth","text":"x Object fdqcs.depth title.fdata overall title fdata plot title.depth overall title depth plot xlab title x axis ylab title y axis col color curves draw.control ist specifies col, lty lwd objects: fdataobj, statistic, . ... arguments passed methods.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/plot.fdqcs.rank.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for 'fdqcs.rank' objects — plot.fdqcs.rank","title":"Plot method for 'fdqcs.rank' objects — plot.fdqcs.rank","text":"Generic function plotting charts object class 'fdqcs.rank'  perform statistical quality control.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/plot.fdqcs.rank.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for 'fdqcs.rank' objects — plot.fdqcs.rank","text":"","code":"# S3 method for fdqcs.rank plot(   x,   title.fdata = NULL,   title.rank = NULL,   xlab = NULL,   ylab = NULL,   col = NULL,   draw.control = NULL,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/plot.fdqcs.rank.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for 'fdqcs.rank' objects — plot.fdqcs.rank","text":"x Object fdqcs.depth title.fdata overall title fdata plot title.rank overall title depth plot xlab title x axis ylab title y axis draw.control ist specifies col, lty lwd objects: fdataobj, statistic, . ... arguments passed methods.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/plot.mqcs.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for 'mqcs' objects — plot.mqcs","title":"Plot method for 'mqcs' objects — plot.mqcs","text":"Generic function plotting Multivarite charts object class 'mqcs' perform statistical  quality control.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/plot.mqcs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for 'mqcs' objects — plot.mqcs","text":"","code":"# S3 method for mqcs plot(x, title, subtitle, xlab, ylab, ylim, ...)  # S3 method for mqcs.t2 plot(   x,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   ylim = NULL,   ... )  # S3 method for mqcs.mcusum plot(   x,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   ylim = NULL,   ... )  # S3 method for mqcs.mewma plot(   x,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   ylim = NULL,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/plot.mqcs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for 'mqcs' objects — plot.mqcs","text":"x Object mqcs (Multivarite Quality Control Statical) title overall title plot subtitle sub title plot xlab title x axis ylab title y axis ylim y limits plot ... arguments passed methods.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/plot.npqcs.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for 'npqcs' objects — plot.npqcs","title":"Plot method for 'npqcs' objects — plot.npqcs","text":"Generic function plotting Multivarite charts object class 'npqcs' perform statistical  quality control.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/plot.npqcs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for 'npqcs' objects — plot.npqcs","text":"","code":"# S3 method for npqcs plot(x, title, subtitle, xlab, ylab, ylim, lim = TRUE, ...)  # S3 method for npqcs.r plot(   x,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   ylim = NULL,   ... )  # S3 method for npqcs.Q plot(   x,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   ylim = NULL,   ... )  # S3 method for npqcs.S plot(   x,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   ylim = NULL,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/plot.npqcs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for 'npqcs' objects — plot.npqcs","text":"x Object npqcs (Multivarite Quality Control Statical) title overall title plot subtitle sub title plot xlab title x axis ylab title y axis ylim y limits plot lim logical value indicating limits constant. ... arguments passed methods.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/plot.qcs.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to create a plotting 'qcs' object — plot.qcs","title":"Function to create a plotting 'qcs' object — plot.qcs","text":"Generic function plotting Shewhart charts object class 'qcs' perform statistical  quality control.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/plot.qcs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to create a plotting 'qcs' object — plot.qcs","text":"","code":"# S3 method for qcs plot(   x,   title,   subtitle,   xlab,   ylab,   ylim,   center.nominal = NULL,   limits.specification = NULL,   limits.alert = NULL,   type.data = c(\"continuous\", \"atributte\", \"dependence\"),   ... )  # S3 method for qcs.xbar plot(   x,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   ylim = NULL,   conf.nsigma.alert = NULL,   center.nominal = NULL,   limits.specification = NULL,   ... )  # S3 method for qcs.S plot(   x,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   ylim = NULL,   conf.nsigma.alert = NULL,   center.nominal = NULL,   limits.specification = NULL,   ... )  # S3 method for qcs.R plot(   x,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   ylim = NULL,   conf.nsigma.alert = NULL,   center.nominal = NULL,   limits.specification = NULL,   ... )  # S3 method for qcs.one plot(   x,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   ylim = NULL,   conf.nsigma.alert = NULL,   center.nominal = NULL,   limits.specification = NULL,   ... )  # S3 method for qcs.p plot(   x,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   ylim = NULL,   conf.nsigma.alert = NULL,   center.nominal = NULL,   limits.specification = NULL,   ... )  # S3 method for qcs.np plot(   x,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   ylim = NULL,   conf.nsigma.alert = NULL,   center.nominal = NULL,   limits.specification = NULL,   ... )  # S3 method for qcs.c plot(   x,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   ylim = NULL,   conf.nsigma.alert = NULL,   center.nominal = NULL,   limits.specification = NULL,   ... )  # S3 method for qcs.u plot(   x,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   ylim = NULL,   conf.nsigma.alert = NULL,   center.nominal = NULL,   limits.specification = NULL,   ... )  # S3 method for qcs.ewma plot(   x,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   ylim = NULL,   ... )  # S3 method for qcs.cusum plot(   x,   title = NULL,   subtitle = NULL,   xlab = NULL,   ylab = NULL,   ylim = NULL,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/plot.qcs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to create a plotting 'qcs' object — plot.qcs","text":"x Object qcs (Quality Control Statical). title overall title plot. subtitle sub title plot. xlab title x axis. ylab title y axis. ylim y limits plot. center.nominal value specifying  center group statistics \"target\" value  process. limits.specification two-value vector  specifying control limits. limits.alert two-value vector  specifying control alert limits. type.data string specifying type data. ... Arguments passed methods. conf.nsigma.alert numeric value used compute control limits, specifying number standard deviations (conf.nsigma > 1) confidence level (0 < conf.nsigma < 1). conf.nsigma numeric value used compute control limits, specifying number standard deviations (conf.nsigma > 1) confidence level (0 < conf.nsigma < 1).","code":""},{"path":"https://mflores72000.github.io/qcr/reference/presion.html","id":null,"dir":"Reference","previous_headings":"","what":"Level of presion data — presion","title":"Level of presion data — presion","text":"shipyard recreational boats manufacturing,  intended optimize control mechanical properties hull yacht models.  made study modulus elasticity tensile strength epoxy resin  (polymer) used, applying different curing pressures measured: 0.1 y 10 MPa.   60 subsamples composed three measurements taken day taken.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/presion.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Level of presion data — presion","text":"data frame 180 observations following 3 variables: presion presion level sample sample id measur pressures measured: 0.1 y 10 MPa","code":""},{"path":"https://mflores72000.github.io/qcr/reference/presion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Level of presion data — presion","text":"","code":"data(presion) attach(presion) #> The following object is masked _by_ .GlobalEnv: #>  #>     presion #> The following object is masked from orangejuice: #>  #>     sample #> The following object is masked from package:qcr: #>  #>     presion summary(presion) #>     presion              sample          measur       #>  Min.   :5.872e+08   Min.   : 1.00   Min.   : 0.100   #>  1st Qu.:9.871e+08   1st Qu.:15.75   1st Qu.: 0.100   #>  Median :1.115e+09   Median :30.50   Median : 0.100   #>  Mean   :1.110e+09   Mean   :30.50   Mean   : 4.885   #>  3rd Qu.:1.257e+09   3rd Qu.:45.25   3rd Qu.:10.000   #>  Max.   :1.390e+09   Max.   :60.00   Max.   :10.000   plot(presion$presion, type=\"b\")  detach(presion)"},{"path":"https://mflores72000.github.io/qcr/reference/qcd.html","id":null,"dir":"Reference","previous_headings":"","what":"Quality Control Data — qcd","title":"Quality Control Data — qcd","text":"Create object class 'qcd' perform statistical quality control. object may used plot Shewhart charts, Multivariate Control Charts, .","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quality Control Data — qcd","text":"","code":"qcd(   data,   var.index = 1,   sample.index = 2,   covar.index = NULL,   covar.names = NULL,   data.name = NULL,   type.data = c(\"continuous\", \"atributte\", \"dependence\"),   sizes = NULL )"},{"path":"https://mflores72000.github.io/qcr/reference/qcd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quality Control Data — qcd","text":"data matrix data-frame contain data, index sample , optionally, covariate(s). var.index scalar column number corresponding observed data variable (variable quality).  Alternativelly can string name quality variable. sample.index scalar column number corresponding index group (sample). covar.index Optional. scalar numeric vector column number(s) corresponding covariate(s). Alternativelly can character vector names covariates. covar.names Optional. string vector strings names covariate columns.  valid one column data. default, takes names original object. data.name string specifying name variable appears plots. provided taken object given data. type.data string specifying type data. sizes Optional. value vector values specifying sample sizes associated group. continuous data, sample sizes obtained counting non-NA elements sample.index vector. attribute variable argument sizes required.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcr.html","id":null,"dir":"Reference","previous_headings":"","what":"Quality Control Review — qcr","title":"Quality Control Review — qcr","text":"Quality Control Review","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quality Control Review — qcr","text":"Univariate multivariate SQC tools completes increases SQC techniques available R. Apart integrating different R packages devoted SQC ('qcc','MSQC'), provides nonparametric tools highly useful Gaussian assumption met. package computes standard univariate control charts individual measurements, X-bar, S, R, p, np, c, u, EWMA CUSUM. addition, includes functions perform multivariate control charts Hotelling T2, MEWMA MCUSUM. representative feature, multivariate nonparametric alternatives based data depth implemented package: r, Q S control charts. addition, Phase II control charts functional data included. package also allows  estimation complete set capability indices first fourth generation, covering nonparametric alternatives, performing corresponding capability analysis graphical outputs, including process capability plots.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.add.html","id":null,"dir":"Reference","previous_headings":"","what":"qcs.add Add a data.frame object with a qcs object — qcs.add","title":"qcs.add Add a data.frame object with a qcs object — qcs.add","text":"function used join two objects type data.frame qcs.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.add.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"qcs.add Add a data.frame object with a qcs object — qcs.add","text":"","code":"qcs.add(x, ...)  # S3 method for default qcs.add(   x,   value,   var.index = NULL,   sample.index = NULL,   covar.index = NULL,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.add.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"qcs.add Add a data.frame object with a qcs object — qcs.add","text":"x Object type qcs ... arguments passed methods. value Object type data.frame var.index scalar column number corresponding observed data variable (variable quality).  Alternativelly can string name quality variable. sample.index scalar column number corresponding index group (sample). covar.index optional. scalar numeric vector column number(s) corresponding covariate(s). Alternativelly can character vector names covariates.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.c.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot Shewhart c chart — qcs.c","title":"Function to plot Shewhart c chart — qcs.c","text":"function used compute statistics required c chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.c.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot Shewhart c chart — qcs.c","text":"","code":"qcs.c(x, ...)  # S3 method for default qcs.c(   x,   var.index = 1,   sample.index = 2,   covar.index = NULL,   covar.names = NULL,   data.name = NULL,   sizes = NULL,   center = NULL,   conf.nsigma = 3,   limits = NULL,   plot = FALSE,   ... )  # S3 method for qcd qcs.c(x, center = NULL, conf.nsigma = 3, limits = NULL, plot = FALSE, ...)"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.c.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot Shewhart c chart — qcs.c","text":"x object qcd (Quality Control Data). ... Arguments passed methods. var.index scalar column number corresponding observed data variable (variable quality).  Alternativelly can string name quality variable. sample.index scalar column number corresponding index group (sample). covar.index Optional. scalar numeric vector column number(s) corresponding covariate(s). Alternativelly can character vector names covariates. covar.names Optional. string vector strings names covariate columns.  valid one column data. default, takes names original object. data.name string specifying name variable appears plots. provided taken object given data. sizes Optional. value vector values specifying sample sizes associated group. continuous data, sample sizes obtained counting non-NA elements sample.index vector. attribute variable argument sizes required. center value specifying center group statistics ''target'' value process. conf.nsigma numeric value used compute control limits, specifying number standard deviations (conf.nsigma > 1) confidence level (0 < conf.nsigma < 1). limits two-value vector specifying control limits. plot Logical value. TRUE c chart plotted.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.c.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot Shewhart c chart — qcs.c","text":"","code":"library(qcr) data(circuit) attach(circuit) #> The following objects are masked from orangejuice: #>  #>     sample, size, trial str(circuit) #> 'data.frame':\t46 obs. of  4 variables: #>  $ x     : int  21 24 16 12 15 5 28 20 31 25 ... #>  $ sample: int  1 2 3 4 5 6 7 8 9 10 ... #>  $ size  : int  100 100 100 100 100 100 100 100 100 100 ... #>  $ trial : logi  TRUE TRUE TRUE TRUE TRUE TRUE ... datos <- circuit datos$sample <- 1:length(datos$x) str(datos) #> 'data.frame':\t46 obs. of  4 variables: #>  $ x     : int  21 24 16 12 15 5 28 20 31 25 ... #>  $ sample: int  1 2 3 4 5 6 7 8 9 10 ... #>  $ size  : int  100 100 100 100 100 100 100 100 100 100 ... #>  $ trial : logi  TRUE TRUE TRUE TRUE TRUE TRUE ... sizes <- datos[,2]  datos.qcd <- qcd(data = datos, var.index = 1,sample.index = 2,                 sizes = size, type.data = \"atributte\") res.qcs <- qcs.c(datos.qcd) summary(res.qcs) #> c chart for datos  #>  #> Summary of group statistics: #>        c         #>  Min.   : 5.00   #>  1st Qu.:16.00   #>  Median :19.00   #>  Mean   :19.17   #>  3rd Qu.:22.00   #>  Max.   :39.00   #>  #> Group sample size:  100 #> Number of groups:  46 #> Center of group statistics:  19.17391 #> Standard deviation:  4.378803  #>  #> Control limits:  #>       LCL      UCL #>  6.037505 32.31032 #>  #> Beyond limits of control:  #> [1] 39  5 #>  #> Violationg runs:  #> [1] 12 15 plot(res.qcs)"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.ca.html","id":null,"dir":"Reference","previous_headings":"","what":"Capability Analysis — qcs.ca","title":"Capability Analysis — qcs.ca","text":"Calculates process capability indices cp, cpk, cpL cpU, cpm, cpmk qcs object normal distribution.  Also, function calculates confidence limits \\(C_p\\) using method described Chou et al. (1990).  Approximate confidence limits \\(C_{pl}\\), \\(C_{pu}\\)  \\(C_{pk}\\) computed using method Bissell (1990).  Confidence limits \\(C_{pm}\\) based method Boyles (1991); method approximate assumes  target midway specification limits. Moreover, calculates process capability indices cnp, cnpk, cnpm, cnpmk qcs object.  histogramm density curve displayed along specification limits,  Quantile-Quantile Plot specified distribution contour graph plotted estimate indice cpm.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.ca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capability Analysis — qcs.ca","text":"","code":"qcs.ca(   object,   limits = c(lsl = -3, usl = 3),   target = NULL,   std.dev = NULL,   nsigmas = 3,   confidence = 0.9973,   plot = TRUE,   main = NULL,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.ca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capability Analysis — qcs.ca","text":"object qcs object type \"qcs.xbar\" \"qcs.one\". limits vector specifying lower upper specification limits. target value specifying target process.  NULL, target set middle value bewteen specification limits. std.dev value specifying within-group standard deviation. nsigmas numeric value specifying number sigmas use. confidence numeric value 0 1 specifying probabilities computing quantiles. values used object values provided. default value 0.9973. plot Logical value indicating whether graph plotted. main Title plot. ... Arguments passed methods.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.ca.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Capability Analysis — qcs.ca","text":"Montgomery, D.C. (1991) Introduction Statistical Quality Control, 2nd ed, New York, John Wiley & Sons.  Tong, L.. Chen, J.P. (1998), Lower con???dence limits process capability  indices nonnormal process distributions. International Journal Quality & Reliability Management,  Vol. 15 . 8/9, pp. 907-19. Vannman, K (1995) Unified Approach Capability Indices. Statitica Sinica,5,805-820. Vannman, K. (2001). Graphical Method Control Process Capability. Frontiers Statistical Quality Control,  6, Editors: H-J Lenz P-TH Wilrich. Physica-Verlag, Heidelberg, 290-311. Hubele Vannman (2004). E???ect Pooled Un-pooled Variance Estimators Cpm Using Subsamples. Journal Quality Technology, 36, 207-222.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.ca.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capability Analysis — qcs.ca","text":"","code":"library(qcr) data(pistonrings)  xbar <- qcs.xbar(pistonrings[1:125,],plot = TRUE)  LSL=73.99; USL=74.01 limits = c(lsl = 73.99, usl = 74.01) qcs.ca(xbar, limits = limits)  #>  #> Process Capability Analysis #>  #> Call: #> qcs.ca(object = xbar, limits = limits) #>  #> Number of obs = 125          Target = 74 #>        Center =  74               LSL =  73.99 #>        StdDev =  0.009785         USL =  74.01 #>  #> Paremetric Capability indices: #>  #>        Value    0.1%   99.9% #> Cp    0.3407  0.2771  0.4065 #> Cp_l  0.3807  0.2739  0.4875 #> Cp_u  0.3006  0.2021  0.3991 #> Cp_k  0.3006  0.1944  0.4068 #> Cpm   0.3382  0.2749  0.4038 #>  #>  #> Non parametric Capability indices: #>  #>         Value #> CNp    1.0082 #> CNpK   0.9275 #> CNpm   0.9799 #> CNpmk  0.9015 #>  #>  #> PPM: #>  #>          Exp<LSL 1.267e+07       Obs<LSL 0 #>          Exp>USL 1.836e+07       Obs>USL 8e+05 #>        Exp Total 3.103e+07     Obs Total 8e+05 #>  #> Test: #>  #>  #> \tAnderson Darling Test for normal distribution #>  #> data:  xbar  #> A = 0.1399, mean = 74.001, sd = 0.005, p-value = 0.9694 #> alternative hypothesis: true distribution is not equal to normal  #>"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.cp.html","id":null,"dir":"Reference","previous_headings":"","what":"Process capability indices (parametric) — qcs.cp","title":"Process capability indices (parametric) — qcs.cp","text":"Calculates \\(Cp\\), \\(Cpm\\) using formulation described Kerstin Vannman(1995).","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.cp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process capability indices (parametric) — qcs.cp","text":"","code":"qcs.cp(   object,   parameters = c(u = 0, v = 0),   limits = c(lsl = -3, usl = 3),   target = NULL,   mu = 0,   std.dev = 1,   nsigmas = 3,   k = 1,   contour = TRUE,   ylim = NULL,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.cp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process capability indices (parametric) — qcs.cp","text":"object qcs object type \"qcs.xbar\" \"qcs.one\". parameters vector specifying u v parameters values.  parameters = c(u=0, v=0), cp indice calculed; parameters = c(u=1, v=0), cpk indice calculed; parameters = c(u=0, v=1), cpm indice calculed; parameters = c(u=1, v=1), cpmk indice calculed. limits vector specifying lower upper specification limits. target value specifying target process.  NULL, target set middle value bewteen specification limits. mu value specifying mean data. std.dev value specifying within-group standard deviation. nsigmas numeric value specifying number sigmas use. k numeric value. capacity index exceeds k value, process capable. contour Logical value indicating whether contour graph plotted. ylim y limits plot. ... Arguments passed methods.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.cp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Process capability indices (parametric) — qcs.cp","text":"Montgomery, D.C. (1991) Introduction Statistical Quality Control, 2nd ed, New York, John Wiley & Sons.  Vannman, K (1995) Unified Approach Capability Indices. Statitica Sinica,5,805-820.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.cp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Process capability indices (parametric) — qcs.cp","text":"","code":"library(qcr) data(pistonrings)  xbar <- qcs.xbar(pistonrings[1:125,],plot = TRUE)  mu <-xbar$center std.dev <-xbar$std.dev LSL=73.99; USL=74.01 qcs.cp(parameters = c(0,0),limits = c(LSL,USL),       mu = mu,std.dev = std.dev,ylim=c(0,1)) #>     Cp  delta  gamma  #> 0.3407 0.1176 0.9785  #calculating all the indices qcs.cp(object = xbar,parameters = c(0,0), limits = c(LSL,USL),ylim=c(0,1))  #>     Cp  delta  gamma  #> 0.3407 0.1176 0.9785  qcs.cp(object = xbar,parameters = c(1,0), limits = c(LSL,USL),ylim=c(0,1))  #>    Cpk  delta  gamma  #> 0.3006 0.1176 0.9785  qcs.cp(object = xbar,parameters = c(0,1), limits = c(LSL,USL),ylim=c(0,1))  #>    Cpm  delta  gamma  #> 0.3382 0.1176 0.9785  qcs.cp(object = xbar,parameters = c(1,1), limits = c(LSL,USL),ylim=c(0,1))  #>   Cpmk  delta  gamma  #> 0.2984 0.1176 0.9785"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.cpn.html","id":null,"dir":"Reference","previous_headings":"","what":"Process capability indices (Nonparametric) — qcs.cpn","title":"Process capability indices (Nonparametric) — qcs.cpn","text":"Calculates \\(CNp\\), \\(CNpm\\) using formulation described Tong Chen (1998).","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.cpn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process capability indices (Nonparametric) — qcs.cpn","text":"","code":"qcs.cpn(   object,   parameters = c(u = 0, v = 0),   limits = c(lsl = -3, usl = 3),   q = c(lq = -3, uq = 3),   target = NULL,   median = 0,   nsigmas = 3,   confidence = 0.9973 )"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.cpn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process capability indices (Nonparametric) — qcs.cpn","text":"object qcs object type \"qcs.xbar\" \"qcs.one\". parameters vector specifying u v parameters values.  parameters = c(u=0, v=0), cp indice calculed; parameters = c(u=1, v=0), cpk indice calculed; parameters = c(u=0, v=1), cpm indice calculed; parameters = c(u=1, v=1), cpmk indice calculed. limits vector specifying lower upper specification limits. q vector specifying lower upper quantiles. values necessary, object value missing. target value specifying target process.  NULL, target set middle value bewteen specification limits. median value specifying median data. nsigmas numeric value specifying number sigmas use. confidence numeric value 0 1 specifying probabilities computing quantiles. values used object values provided. default value 0.9973.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.cpn.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Process capability indices (Nonparametric) — qcs.cpn","text":"Montgomery, D.C. (1991) Introduction Statistical Quality Control, 2nd ed, New York, John Wiley & Sons.  Tong, L.. Chen, J.P. (1998), Lower confidence limits process capability  indices nonnormal process distributions. International Journal Quality & Reliability Management,  Vol. 15 . 8/9, pp. 907-19.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.cpn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Process capability indices (Nonparametric) — qcs.cpn","text":"","code":"library(qcr) ##' data(pistonrings)  xbar <- qcs.xbar(pistonrings[1:125,],plot = TRUE)  x<-xbar$statistics[[1]] LSL=73.99; USL=74.01 median <-median(x) lq=as.numeric(quantile(x,probs=0.00135)) uq=as.numeric(quantile(x,probs=0.99865)) qcs.cpn(parameters = c(0,0),limits = c(LSL,USL),        median = median, q=c(lq,uq)) #>    CNp  #> 1.0082  qcs.cpn(object = xbar,parameters = c(0,0), limits = c(LSL,USL)) #>    CNp  #> 1.0082  qcs.cpn(object = xbar,parameters = c(1,0), limits = c(LSL,USL)) #>   CNpk  #> 0.9275  qcs.cpn(object = xbar,parameters = c(0,1), limits = c(LSL,USL)) #>   CNpm  #> 0.9799  qcs.cpn(object = xbar,parameters = c(1,1), limits = c(LSL,USL)) #>  CNpmk  #> 0.9015"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.cusum.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot the cusum chart — qcs.cusum","title":"Function to plot the cusum chart — qcs.cusum","text":"function used compute statistics required cusum chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.cusum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot the cusum chart — qcs.cusum","text":"","code":"qcs.cusum(x, ...)  # S3 method for default qcs.cusum(   x,   var.index = 1,   sample.index = 2,   covar.index = NULL,   covar.names = NULL,   data.name = NULL,   sizes = NULL,   center = NULL,   std.dev = NULL,   decision.interval = 5,   se.shift = 1,   plot = FALSE,   ... )  # S3 method for qcd qcs.cusum(   x,   center = NULL,   std.dev = NULL,   decision.interval = 5,   se.shift = 1,   plot = FALSE,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.cusum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot the cusum chart — qcs.cusum","text":"x Object qcd (Quality Control Data). ... Arguments passed methods. var.index scalar column number corresponding observed data variable (variable quality).  Alternativelly can string name quality variable. sample.index scalar column number corresponding index group (sample). covar.index Optional. scalar numeric vector column number(s) corresponding covariate(s). Alternativelly can character vector names covariates. covar.names Optional. string vector strings names covariate columns.  valid one column data. default, takes names original object. data.name string specifying name variable appears plots. provided taken object given data. sizes value vector values specifying sample sizes associated group. center value specifying center group statistics ''target'' value process. std.dev value available method specifying within-group standard deviation(s) process.  Several methods available estimating standard deviation. decision.interval numeric value specifying number standard errors summary statistics cumulative sum control. se.shift amount shift detect process, measured standard errors summary statistics. plot Logical value. TRUE cusum chart plotted.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.cusum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot the cusum chart — qcs.cusum","text":"","code":"library(qcr) data(pistonrings) attach(pistonrings) #> The following objects are masked from circuit: #>  #>     sample, trial #> The following objects are masked from orangejuice: #>  #>     sample, trial res.qcd <- qcd(pistonrings, type.data = \"dependence\") res.qcs <- qcs.cusum(res.qcd, type = \"cusum\") summary(res.qcs) #> cusum chart for pistonrings  #>  #> Summary of group statistics: #>      cusum       #>  Min.   :73.99   #>  1st Qu.:74.00   #>  Median :74.00   #>  Mean   :74.00   #>  3rd Qu.:74.01   #>  Max.   :74.02   #>  #> Group sample size:  5 #> Number of groups:  40 #> Center of group statistics:  74.0036 #> Standard deviation:  0.01007094  #>  #> Control limits:  #> [1] -5  5 #>  #> Beyond limits of control:  #>  [1] 73.9902 74.0060 73.9966 74.0008 74.0074 73.9982 74.0092 73.9998 74.0016 #> [10] 74.0024 73.9982 73.9922 73.9974 #>  #> Violationg runs:  #> [1] 74.0196 74.0234 74.0128 plot(res.qcs)"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.ewma.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot ewma chart — qcs.ewma","title":"Function to plot ewma chart — qcs.ewma","text":"function used compute statistics required ewma chart. function used compute statistics required ewma chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.ewma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot ewma chart — qcs.ewma","text":"","code":"qcs.ewma(x, ...)  # S3 method for default qcs.ewma(   x,   var.index = 1,   sample.index = 2,   covar.index = NULL,   covar.names = NULL,   data.name = NULL,   sizes = NULL,   center = NULL,   std.dev = NULL,   nsigma = 3,   lambda = 0.2,   plot = FALSE,   ... )  # S3 method for qcd qcs.ewma(   x,   center = NULL,   std.dev = NULL,   nsigma = 3,   lambda = 0.2,   plot = FALSE,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.ewma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot ewma chart — qcs.ewma","text":"x Object qcd (Quality Control Data). ... Arguments passed methods. var.index scalar column number corresponding observed data variable (variable quality).  Alternativelly can string name quality variable. sample.index scalar column number corresponding index group (sample). covar.index Optional. scalar numeric vector column number(s) corresponding covariate(s). Alternativelly can character vector names covariates. covar.names Optional. string vector strings names covariate columns.  valid one column data. default, takes names original object. data.name string specifying name variable appears plots. provided taken object given data. sizes Optional. value vector values specifying sample sizes associated group. continuous data, sample sizes obtained counting non-NA elements sample.index vector. attribute variable argument sizes required. center value specifying center group statistics ''target'' value process. std.dev value available method specifying within-group standard deviation(s) process. Several methods available estimating standard deviation case continuous process variable. nsigma numeric value used compute control limits, specifying number standard deviations. lambda smoothing parameter \\(0 \\le \\lambda \\le 1\\) plot Logical value. TRUE ewma chart plotted.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.ewma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot ewma chart — qcs.ewma","text":"","code":"library(qcr) data(pistonrings) attach(pistonrings) #> The following objects are masked from pistonrings (pos = 3): #>  #>     diameter, sample, trial #> The following objects are masked from circuit: #>  #>     sample, trial #> The following objects are masked from orangejuice: #>  #>     sample, trial res.qcd <- qcd(pistonrings, type.data = \"dependence\") res.qcs <- qcs.ewma(res.qcd, type = \"ewma\") summary(res.qcs) #> ewma chart for pistonrings  #>  #> Summary of group statistics: #>       ewma       #>  Min.   :73.99   #>  1st Qu.:74.00   #>  Median :74.00   #>  Mean   :74.00   #>  3rd Qu.:74.01   #>  Max.   :74.02   #>  #> Group sample size:  5 #> Number of groups:  40 #> Center of group statistics:  74.0036 #> Standard deviation:  0.01007094  #>  #> Control limits:  #>         LCL      UCL #> 1  74.00090 74.00631 #> 2  74.00014 74.00707 #> 3  73.99974 74.00747 #> 4  73.99950 74.00771 #> 5  73.99935 74.00786 #> 6  73.99926 74.00795 #> 7  73.99920 74.00801 #> 8  73.99916 74.00805 #> 9  73.99914 74.00807 #> 10 73.99913 74.00808 #> 11 73.99912 74.00809 #> 12 73.99911 74.00810 #> 13 73.99911 74.00810 #> 14 73.99911 74.00810 #> 15 73.99910 74.00811 #> 16 73.99910 74.00811 #> 17 73.99910 74.00811 #> 18 73.99910 74.00811 #> 19 73.99910 74.00811 #> 20 73.99910 74.00811 #> 21 73.99910 74.00811 #> 22 73.99910 74.00811 #> 23 73.99910 74.00811 #> 24 73.99910 74.00811 #> 25 73.99910 74.00811 #> 26 73.99910 74.00811 #> 27 73.99910 74.00811 #> 28 73.99910 74.00811 #> 29 73.99910 74.00811 #> 30 73.99910 74.00811 #> 31 73.99910 74.00811 #> 32 73.99910 74.00811 #> 33 73.99910 74.00811 #> 34 73.99910 74.00811 #> 35 73.99910 74.00811 #> 36 73.99910 74.00811 #> 37 73.99910 74.00811 #> 38 73.99910 74.00811 #> 39 73.99910 74.00811 #> 40 73.99910 74.00811 #>  #> Beyond limits of control:  #> [1] 73.9902 #>  #> Violationg runs:  #> [1] 73.9966 plot(res.qcs)"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.hat.cpm.html","id":null,"dir":"Reference","previous_headings":"","what":"Process capability index (estimate cpm) — qcs.hat.cpm","title":"Process capability index (estimate cpm) — qcs.hat.cpm","text":"Estimate  \"cpm\" using method described Kerstin Vannman(2001).","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.hat.cpm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process capability index (estimate cpm) — qcs.hat.cpm","text":"","code":"qcs.hat.cpm(   object,   limits = c(lsl = -3, usl = 3),   target = NULL,   mu = 0,   std.dev = 1,   nsigmas = 3,   k0 = 1,   alpha = 0.05,   n = 50,   contour = TRUE,   ylim = NULL,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.hat.cpm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process capability index (estimate cpm) — qcs.hat.cpm","text":"object qcs object type \"qcs.xbar\" \"qcs.one\". limits vector specifying lower upper specification limits. target value specifying target process.  NULL, target set middle value bewteen specification limits. mu value specifying mean data. std.dev value specifying within-group standard deviation. nsigmas numeric value specifying number sigmas use. k0 numeric value. capacity index exceeds k value, process capable. alpha significance level (0.05 default) n Size sample. contour Logical value indicating whether contour graph plotted. ylim y limits plot. ... Arguments passed methods.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.hat.cpm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Process capability index (estimate cpm) — qcs.hat.cpm","text":"Montgomery, D.C. (1991) Introduction Statistical Quality Control, 2nd ed, New York, John Wiley & Sons.  Vannman, K. (2001). Graphical Method Control Process Capability. Frontiers Statistical Quality Control,  6, Editors: H-J Lenz P-TH Wilrich. Physica-Verlag, Heidelberg, 290-311. Hubele Vannman (2004). E???ect Pooled Un-pooled Variance Estimators Cpm Using Subsamples. Journal Quality Technology, 36, 207-222.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.hat.cpm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Process capability index (estimate cpm) — qcs.hat.cpm","text":"","code":"library(qcr) data(pistonrings)  xbar <- qcs.xbar(pistonrings[1:125,],plot = TRUE)  mu <-xbar$center std.dev <-xbar$std.dev LSL=73.99; USL=74.01 qcs.hat.cpm(limits = c(LSL,USL),            mu = mu,std.dev = std.dev,ylim=c(0,1)) qcs.hat.cpm(object = xbar, limits = c(LSL,USL),ylim=c(0,1))"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.html","id":null,"dir":"Reference","previous_headings":"","what":"Quality Control Statistics — qcs","title":"Quality Control Statistics — qcs","text":"Create object class 'qcs' perform statistical quality control. object may used plot Shewhart charts, Multivariate Control Charts, .","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quality Control Statistics — qcs","text":"","code":"qcs(   x,   sample.index,   sizes = NULL,   type = c(\"xbar\", \"R\", \"S\", \"one\", \"p\", \"np\", \"c\", \"u\", \"ewma\", \"cusum\"),   center = NULL,   std.dev,   conf.nsigma = 3,   limits = NULL,   type.data = c(\"continuous\", \"atributte\", \"dependence\"),   lambda = 0.2,   decision.interval = 5,   se.shift = 1 )  qcs.continuous(   x,   sample.index,   sizes = NULL,   type = c(\"xbar\", \"R\", \"S\", \"one\"),   center = NULL,   std.dev,   conf.nsigma = 3,   limits = NULL )  qcs.atributte(   x,   sample.index = NULL,   sizes = NULL,   type = c(\"p\", \"np\", \"c\", \"u\"),   center = NULL,   conf.nsigma = 3,   limits = NULL )  qcs.dependence(   x,   sample.index = NULL,   sizes = NULL,   type = c(\"ewma\", \"cusum\"),   center = NULL,   std.dev,   nsigma = 3,   lambda = 0.2,   decision.interval = 5,   se.shift = 1 )"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quality Control Statistics — qcs","text":"x vector containing observed data. sample.index scalar column number corresponding index  group (sample). sizes value vector values specifying sample sizes associated group. continuous data sample sizes obtained counting non-NA elements sample.index vector. \"p\", \"np\" \"u\" charts argument sizes required. type character string specifying group statistics compute: center value specifying center group statistics ''target'' value process. std.dev value available method specifying within-group standard deviation(s) process. Several methods available estimating standard deviation case continuous process variable. conf.nsigma numeric value used compute control limits, specifying number standard deviations (conf.nsigma > 1) confidence level (0 < conf.nsigma < 1). limits two-value vector specifying control limits. type.data string specifying el type de data. lambda smoothing parameter \\(0 \\le \\lambda \\le 1\\) decision.interval numeric value specifying number standard errors summary statistics cumulative sum control. se.shift amount shift detect process, measured standard errors summary statistics. nsigma numeric value used compute control limits, specifying number standard deviations.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quality Control Statistics — qcs","text":"Returns object class 'qcs'.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Quality Control Statistics — qcs","text":"Montgomery, D.C. (2000) Introduction Statistical Quality Control, 4th ed. New York: John Wiley & Sons.  Wetherill, G.B. Brown, D.W. (1991) Statistical Process Control. New York: Chapman & Hall.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.np.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot Shewhart np chart — qcs.np","title":"Function to plot Shewhart np chart — qcs.np","text":"function used compute statistics required np chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.np.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot Shewhart np chart — qcs.np","text":"","code":"qcs.np(x, ...)  # S3 method for default qcs.np(   x,   var.index = 1,   sample.index = 2,   covar.index = NULL,   covar.names = NULL,   data.name = NULL,   sizes = NULL,   center = NULL,   conf.nsigma = 3,   limits = NULL,   plot = FALSE,   ... )  # S3 method for qcd qcs.np(x, center = NULL, conf.nsigma = 3, limits = NULL, plot = FALSE, ...)"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.np.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot Shewhart np chart — qcs.np","text":"x R object (used select method). See details. ... Arguments passed methods. var.index scalar column number corresponding observed data variable (variable quality).  Alternativelly can string name quality variable. sample.index scalar column number corresponding index group (sample). covar.index Optional. scalar numeric vector column number(s) corresponding covariate(s). Alternativelly can character vector names covariates. covar.names Optional. string vector strings names covariate columns.  valid one column data. default, takes names original object. data.name string specifying name variable appears plots. provided taken object given data. sizes Optional. value vector values specifying sample sizes associated group. continuous data, sample sizes obtained counting non-NA elements sample.index vector. attribute variable argument sizes required. center value specifying center group statistics ''target'' value process. conf.nsigma numeric value used compute control limits, specifying number standard deviations (conf.nsigma > 1) confidence level (0 < conf.nsigma < 1). limits two-values vector specifying control limits. plot Logical value. TRUE np chart plotted.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.np.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function to plot Shewhart np chart — qcs.np","text":"default method qcs.np.default parameter x matrix data-frame contain data, index sample , optionally, covariate(s).","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.np.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot Shewhart np chart — qcs.np","text":"","code":"library(qcr) data(orangejuice) str(orangejuice) #> 'data.frame':\t54 obs. of  4 variables: #>  $ D     : int  12 15 8 10 4 7 16 9 14 10 ... #>  $ sample: int  1 2 3 4 5 6 7 8 9 10 ... #>  $ size  : int  50 50 50 50 50 50 50 50 50 50 ... #>  $ trial : logi  TRUE TRUE TRUE TRUE TRUE TRUE ... attach(orangejuice) #> The following objects are masked from pistonrings (pos = 3): #>  #>     sample, trial #> The following objects are masked from pistonrings (pos = 4): #>  #>     sample, trial #> The following objects are masked from circuit: #>  #>     sample, size, trial #> The following objects are masked from orangejuice (pos = 6): #>  #>     D, sample, size, trial  datos.qcd <- qcd(data = orangejuice, var.index = 1, sample.index = 2,                 sizes = size, type.data = \"atributte\")  res.qcs <- qcs.np(datos.qcd) summary(res.qcs) #> np chart for orangejuice  #>  #> Summary of group statistics: #>        np         #>  Min.   : 2.000   #>  1st Qu.: 5.000   #>  Median : 7.000   #>  Mean   : 8.889   #>  3rd Qu.:12.000   #>  Max.   :24.000   #>  #> Group sample size:  50 #> Number of groups:  54 #> Center of group statistics:  8.888889 #> Standard deviation:  2.70345  #>  #> Control limits:  #>        LCL      UCL #>  0.7785388 16.99924 #>  #> Beyond limits of control:  #> [1] 17 22 20 18 24 #>  #> Violationg runs:  #>  [1]  9 12  6  2  4  3  6  5  4  8  5  6  7  5  6  3  5 plot(res.qcs)   datos.qcs <- qcs.np(orangejuice[trial,c(1,2)], sizes = orangejuice[trial,3]) plot(datos.qcs)"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.one.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot the Shewhart xbar.one chart — qcs.one","title":"Function to plot the Shewhart xbar.one chart — qcs.one","text":"function used compute statistics required xbar.one chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.one.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot the Shewhart xbar.one chart — qcs.one","text":"","code":"qcs.one(x, ...)  # S3 method for default qcs.one(   x,   var.index = 1,   sample.index = 2,   covar.index = NULL,   covar.names = NULL,   data.name = NULL,   sizes = NULL,   center = NULL,   std.dev = c(\"MR\", \"SD\"),   k = 2,   conf.nsigma = 3,   limits = NULL,   plot = FALSE,   ... )  # S3 method for qcd qcs.one(   x,   center = NULL,   std.dev = c(\"MR\", \"SD\"),   k = 2,   conf.nsigma = 3,   limits = NULL,   plot = FALSE,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.one.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot the Shewhart xbar.one chart — qcs.one","text":"x Object qcd (Quality Control Data). ... Arguments passed methods. var.index scalar column number corresponding observed data variable (variable quality).  Alternativelly can string name quality variable. sample.index scalar column number corresponding index group (sample). covar.index Optional. scalar numeric vector column number(s) corresponding covariate(s). Alternativelly can character vector names covariates. covar.names Optional. string vector strings names covariate columns.  valid one column data. default, takes names original object. data.name string specifying name variable appears plots. provided taken object given data. sizes Optional. value vector values specifying sample sizes associated group. continuous data sample sizes obtained counting non-NA elements sample.index vector. attribute variable argument sizes required. center value specifying center group statistics ''target'' value process. std.dev value available method specifying within-group standard deviation(s) process. Several methods available estimating standard deviation case continuous process variable. k Number successive pairs observations computing standard deviation based moving ranges k points. conf.nsigma numeric value used compute control limits, specifying number standard deviations (conf.nsigma > 1) confidence level (0 < conf.nsigma < 1). limits two-value vector specifying control limits. plot Logical value. TRUE xbar.one chart plotted.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.one.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot the Shewhart xbar.one chart — qcs.one","text":"","code":"## ##  Continuous data  ## library(qcr) x <- c(33.75, 33.05, 34, 33.81, 33.46, 34.02, 33.68, 33.27, 33.49, 33.20,       33.62, 33.00, 33.54, 33.12, 33.84)  sample <- 1:length(x) datos <- data.frame(x,sample) datos.qcd <- qcd(datos)  res.qcs <- qcs.one(datos.qcd) class(res.qcs) #> [1] \"qcs.one\" \"qcs\"     summary(res.qcs)   #> one chart for datos  #>  #> Summary of group statistics: #>       one        #>  Min.   :33.00   #>  1st Qu.:33.23   #>  Median :33.54   #>  Mean   :33.52   #>  3rd Qu.:33.78   #>  Max.   :34.02   #>  #> Group sample size:  1 #> Number of groups:  15 #> Center of group statistics:  33.52333 #> Standard deviation:  0.4261651  #>  #> Control limits:  #>       LCL      UCL #>  32.24484 34.80183 #>  #> Number beyond limits: 0  #>  #> Number violationg runs: 0   plot(res.qcs, title = \"Control Chart Xbar.one for pistonrings\")"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.p.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot Shewhart p chart — qcs.p","title":"Function to plot Shewhart p chart — qcs.p","text":"function used compute statistics required p chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot Shewhart p chart — qcs.p","text":"","code":"qcs.p(x, ...)  # S3 method for default qcs.p(   x,   var.index = 1,   sample.index = 2,   covar.index = NULL,   covar.names = NULL,   data.name = NULL,   sizes = NULL,   center = NULL,   conf.nsigma = 3,   limits = NULL,   plot = FALSE,   ... )  # S3 method for qcd qcs.p(x, center = NULL, conf.nsigma = 3, limits = NULL, plot = FALSE, ...)"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot Shewhart p chart — qcs.p","text":"x R object (used select method). See details. ... Arguments passed methods. var.index scalar column number corresponding observed data variable (variable quality).  Alternativelly can string name quality variable. sample.index scalar column number corresponding index group (sample). covar.index Optional. scalar numeric vector column number(s) corresponding covariate(s). Alternativelly can character vector names covariates. covar.names Optional. string vector strings names covariate columns.  valid one column data. default, takes names original object. data.name string specifying name variable appears plots. provided taken object given data. sizes Optional. value vector values specifying sample sizes associated group. continuous data, sample sizes obtained counting non-NA elements sample.index vector. attribute variable argument sizes required. center value specifying center group statistics ''target'' value process. conf.nsigma numeric value used compute control limits, specifying number standard deviations (conf.nsigma > 1) confidence level (0 < conf.nsigma < 1). limits two-values vector specifying control limits. plot Logical value. TRUE p chart plotted.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.p.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function to plot Shewhart p chart — qcs.p","text":"default method qcs.p.default parameter x matrix data-frame contain data, index sample , optionally, covariate(s).","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.p.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot Shewhart p chart — qcs.p","text":"","code":"library(qcr) data(orangejuice) str(orangejuice) #> 'data.frame':\t54 obs. of  4 variables: #>  $ D     : int  12 15 8 10 4 7 16 9 14 10 ... #>  $ sample: int  1 2 3 4 5 6 7 8 9 10 ... #>  $ size  : int  50 50 50 50 50 50 50 50 50 50 ... #>  $ trial : logi  TRUE TRUE TRUE TRUE TRUE TRUE ... attach(orangejuice) #> The following objects are masked from orangejuice (pos = 3): #>  #>     D, sample, size, trial #> The following objects are masked from pistonrings (pos = 4): #>  #>     sample, trial #> The following objects are masked from pistonrings (pos = 5): #>  #>     sample, trial #> The following objects are masked from circuit: #>  #>     sample, size, trial #> The following objects are masked from orangejuice (pos = 7): #>  #>     D, sample, size, trial  datos.qcd <- qcd(data = orangejuice, var.index = 1, sample.index = 2,                 sizes = size, type.data = \"atributte\")  res.qcs <- qcs.p(datos.qcd) summary(res.qcs) #> p chart for orangejuice  #>  #> Summary of group statistics: #>        p          #>  Min.   :0.0400   #>  1st Qu.:0.1000   #>  Median :0.1400   #>  Mean   :0.1778   #>  3rd Qu.:0.2400   #>  Max.   :0.4800   #>  #> Group sample size:  50 #> Number of groups:  54 #> Center of group statistics:  0.1777778 #> Standard deviation:  0.3823256  #>  #> Control limits:  #>         LCL       UCL #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  0.01557078 0.3399848 #>  #> Beyond limits of control:  #> [1] 0.34 0.44 0.40 0.36 0.48 #>  #> Violationg runs:  #>  [1] 0.18 0.24 0.12 0.04 0.08 0.06 0.12 0.10 0.08 0.16 0.10 0.12 0.14 0.10 0.12 #> [16] 0.06 0.10 plot(res.qcs)   datos.qcs <- qcs.p(orangejuice[trial,c(1,2)], sizes = orangejuice[trial,3]) plot(datos.qcs)"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.pcr.html","id":null,"dir":"Reference","previous_headings":"","what":"Process capability indices for a given dataset and distribution — qcs.pcr","title":"Process capability indices for a given dataset and distribution — qcs.pcr","text":"Calculates process capability indices cp, cpk, cpkL cpkU given dataset distribution.  histogramm density curve displayed along specification limits  Quantile-Quantile Plot specified distribution.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.pcr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process capability indices for a given dataset and distribution — qcs.pcr","text":"","code":"qcs.pcr(   object,   distribution = c(\"normal\", \"beta\", \"chi-squared\", \"exponential\", \"f\", \"geometric\",     \"lognormal\", \"log-normal\", \"logistic\", \"t\", \"negative binomial\", \"poisson\",     \"weibull\", \"gamma\"),   limits = c(lsl = -3, usl = 3),   target = NULL,   std.dev = NULL,   boxcox = FALSE,   lambda = c(-5, 5),   confidence = 0.9973,   plot = TRUE,   main = NULL,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.pcr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process capability indices for a given dataset and distribution — qcs.pcr","text":"object qcs object type \"qcs.xbar\" \"qcs.one\". distribution character string representing probability distribution data, :\"normal\",\"beta\", \"chi-squared\",  \"exponential\", \"f\", \"geometric\", \"lognormal\", \"log-normal\", \"logistic\",\"t\", \"negative binomial\", \"poisson\", \"weibull\", \"gamma\". limits vector specifying lower upper specification limits. target value specifying target process.  NULL, target set middle value bewteen specification limits. std.dev value specifying within-group standard deviation. boxcox Logical value (default FALSE). TRUE, perform Box-Cox transformation. lambda vector specifying numeric value indicating lambda transformation confidence numeric value 0 1 specifying nivel computing specification limits. plot Logical value indicating whether graph plotted. main Title plot. ... Arguments passed methods.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.pcr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Process capability indices for a given dataset and distribution — qcs.pcr","text":"Montgomery, D.C. (1991) Introduction Statistical Quality Control, 2nd ed, New York, John Wiley & Sons.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.pcr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Process capability indices for a given dataset and distribution — qcs.pcr","text":"","code":"library(qcr) data(pistonrings)  xbar <- qcs.xbar(pistonrings[1:125,],plot = TRUE)  limits = c(lsl = 73.99, usl = 74.01) qcs.pcr(xbar, \"normal\", limits = limits)   #>  #> Process Capability Analysis #>  #> Call: #> qcs.pcr(object = xbar, distribution = \"normal\", limits = limits) #>  #> Number of obs = 125          Target = 74 #>        Center =  74               LSL =  73.99 #>        StdDev =  0.009785         USL =  74.01 #>  #> Capability indices: #>  #>        Value #> Cp    0.3407 #> Cp_l  0.3807 #> Cp_u  0.3006 #> Cp_k  0.3006 #>  #>  #> PPM: #>  #>          Exp<LSL 1.267e+05       Obs<LSL 0 #>          Exp>USL 1.836e+05       Obs>USL 1e+12 #>        Exp Total 3.103e+05     Obs Total 1e+12 #>  #> Test: #>  #>  #> \tAnderson Darling Test for normal distribution #>  #> data:  x  #> A = 0.1399, mean = 74.001, sd = 0.005, p-value = 0.9694 #> alternative hypothesis: true distribution is not equal to normal  #>  qcs.pcr(xbar, \"weibull\", limits = limits)  #>  #> Process Capability Analysis #>  #> Call: #> qcs.pcr(object = xbar, distribution = \"weibull\", limits = limits) #>  #> Number of obs = 125          Target = 74 #>        Center =  74               LSL =  73.99 #>        StdDev =  0.009785         USL =  74.01 #>  #> Capability indices: #>  #>        Value #> Cp    0.5801 #> Cp_l  0.4861 #> Cp_u  0.8402 #> Cp_k  0.4861 #>  #>  #> PPM: #>  #>          Exp<LSL 3.283e+04       Obs<LSL 0 #>          Exp>USL 9965            Obs>USL 1e+12 #>        Exp Total 4.279e+04     Obs Total 1e+12 #>  #> Test: #>  #>  #> \tAnderson Darling Test for weibull distribution #>  #> data:  x  #> A = 0.7297, shape = 18232.755, scale = 74.004, p-value <= 0.05 #> alternative hypothesis: true distribution is not equal to weibull  #>"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.R.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot Shewhart R chart — qcs.R","title":"Function to plot Shewhart R chart — qcs.R","text":"function used compute statistics required R chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.R.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot Shewhart R chart — qcs.R","text":"","code":"qcs.R(x, ...)  # S3 method for default qcs.R(   x,   var.index = 1,   sample.index = 2,   covar.index = NULL,   covar.names = NULL,   data.name = NULL,   sizes = NULL,   center = NULL,   std.dev = c(\"UWAVE-R\", \"MVLUE-R\"),   conf.nsigma = 3,   limits = NULL,   plot = FALSE,   ... )  # S3 method for qcd qcs.R(   x,   center = NULL,   std.dev = c(\"UWAVE-R\", \"MVLUE-R\"),   conf.nsigma = 3,   limits = NULL,   plot = FALSE,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.R.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot Shewhart R chart — qcs.R","text":"x R object (used select method). See details. ... Arguments passed methods. var.index scalar column number corresponding observed data variable (variable quality).  Alternativelly can string name quality variable. sample.index scalar column number corresponding index group (sample). covar.index Optional. scalar numeric vector column number(s) corresponding covariate(s). Alternativelly can character vector names covariates. covar.names Optional. string vector strings names covariate columns.  valid one column data. default, takes names original object. data.name string specifying name variable appears plots. provided taken object given data. sizes Optional. value vector values specifying sample sizes associated group. continuous data, sample sizes obtained counting non-NA elements sample.index vector. attribute variable argument sizes required. center value specifying center group statistics ''target'' value process. std.dev value available method specifying within-group standard deviation(s) process. Several methods available estimating standard deviation case continuous process variable. conf.nsigma numeric value used compute control limits, specifying number standard deviations (conf.nsigma > 1) confidence level (0 < conf.nsigma < 1). limits two-values vector specifying control limits. plot Logical value. TRUE R chart plotted.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.R.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function to plot Shewhart R chart — qcs.R","text":"default method qcs.R.default parameter x matrix data-frame contain data, index sample , optionally, covariate(s).","code":""},{"path":[]},{"path":"https://mflores72000.github.io/qcr/reference/qcs.R.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot Shewhart R chart — qcs.R","text":"","code":"## ##  Continuous data  ## library(qcr) data(pistonrings) str(pistonrings) #> 'data.frame':\t200 obs. of  3 variables: #>  $ diameter: num  74 74 74 74 74 ... #>  $ sample  : int  1 1 1 1 1 2 2 2 2 2 ... #>  $ trial   : logi  TRUE TRUE TRUE TRUE TRUE TRUE ... pistonrings.qcd<-qcd(pistonrings)  class(pistonrings.qcd) #> [1] \"qcd\"        \"data.frame\"  res.qcs <- qcs.R(pistonrings.qcd) class(res.qcs) #> [1] \"qcs.R\" \"qcs\"   plot(res.qcs,title=\"Control Chart R for pistonrings\")  summary(res.qcs)   #> R chart for pistonrings  #>  #> Summary of group statistics: #>        R           #>  Min.   :0.00800   #>  1st Qu.:0.01875   #>  Median :0.02250   #>  Mean   :0.02343   #>  3rd Qu.:0.02675   #>  Max.   :0.04400   #>  #> Group sample size:  5 #> Number of groups:  40 #> Center of group statistics:  0.023425 #> Standard deviation:  0.01007094  #>  #> Control limits:  #>  LCL        UCL #>    0 0.04953145 #>  #> Number beyond limits: 0  #>  #> Number violationg runs: 0"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.S.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot Shewhart S chart — qcs.S","title":"Function to plot Shewhart S chart — qcs.S","text":"function used compute statistics required S chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.S.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot Shewhart S chart — qcs.S","text":"","code":"qcs.S(x, ...)  # S3 method for default qcs.S(   x,   var.index = 1,   sample.index = 2,   covar.index = NULL,   covar.names = NULL,   data.name = NULL,   sizes = NULL,   center = NULL,   std.dev = c(\"UWAVE-SD\", \"MVLUE-SD\", \"RMSDF\"),   conf.nsigma = 3,   limits = NULL,   plot = FALSE,   ... )  # S3 method for qcd qcs.S(   x,   center = NULL,   std.dev = c(\"UWAVE-SD\", \"MVLUE-SD\", \"RMSDF\"),   conf.nsigma = 3,   limits = NULL,   plot = FALSE,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.S.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot Shewhart S chart — qcs.S","text":"x R object (used select method). See details. ... Arguments passed methods. var.index scalar column number corresponding observed data variable (variable quality).  Alternativelly can string name quality variable. sample.index scalar column number corresponding index group (sample). covar.index Optional. scalar numeric vector column number(s) corresponding covariate(s). Alternativelly can character vector names covariates. covar.names Optional. string vector strings names covariate columns.  valid one column data. default, takes names original object. data.name string specifying name variable appears plots. provided taken object given data. sizes Optional. value vector values specifying sample sizes associated group. continuous data, sample sizes obtained counting non-NA elements sample.index vector. attribute variable argument sizes required. center value specifying center group statistics ''target'' value process. std.dev value available method specifying within-group standard deviation(s) process. Several methods available estimating standard deviation case continuous process variable. conf.nsigma numeric value used compute control limits, specifying number standard deviations (conf.nsigma > 1) confidence level (0 < conf.nsigma < 1). limits two-values vector specifying control limits. plot Logical value. TRUE S chart plotted.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.S.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function to plot Shewhart S chart — qcs.S","text":"default method qcs.S.default parameter x matrix data-frame contain data, index sample , optionally, covariate(s).","code":""},{"path":[]},{"path":"https://mflores72000.github.io/qcr/reference/qcs.S.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot Shewhart S chart — qcs.S","text":"","code":"## ##  Continuous data  ## library(qcr) data(pistonrings) str(pistonrings) #> 'data.frame':\t200 obs. of  3 variables: #>  $ diameter: num  74 74 74 74 74 ... #>  $ sample  : int  1 1 1 1 1 2 2 2 2 2 ... #>  $ trial   : logi  TRUE TRUE TRUE TRUE TRUE TRUE ... pistonrings.qcd<-qcd(pistonrings)  class(pistonrings.qcd) #> [1] \"qcd\"        \"data.frame\"  res.qcs <- qcs.S(pistonrings.qcd) class(res.qcs) #> [1] \"qcs.S\" \"qcs\"   plot(res.qcs,title=\"Control Chart S for pistonrings\")  summary(res.qcs)   #> S chart for pistonrings  #>  #> Summary of group statistics: #>        S            #>  Min.   :0.002864   #>  1st Qu.:0.007294   #>  Median :0.008703   #>  Mean   :0.009436   #>  3rd Qu.:0.011566   #>  Max.   :0.016547   #>  #> Group sample size:  5 #> Number of groups:  40 #> Center of group statistics:  0.009435682 #> Standard deviation:  0.01003811  #>  #> Control limits:  #>  LCL        UCL #>    0 0.01971112 #>  #> Number beyond limits: 0  #>  #> Number violationg runs: 0"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.u.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot Shewhart u chart — qcs.u","title":"Function to plot Shewhart u chart — qcs.u","text":"function used compute statistics required u chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.u.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot Shewhart u chart — qcs.u","text":"","code":"qcs.u(x, ...)  # S3 method for default qcs.u(   x,   var.index = 1,   sample.index = 2,   covar.index = NULL,   covar.names = NULL,   data.name = NULL,   sizes = NULL,   center = NULL,   conf.nsigma = 3,   limits = NULL,   plot = FALSE,   ... )  # S3 method for qcd qcs.u(x, center = NULL, conf.nsigma = 3, limits = NULL, plot = FALSE, ...)"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.u.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot Shewhart u chart — qcs.u","text":"x R object (used select method). See details. ... Arguments passed methods. var.index scalar column number corresponding observed data variable (variable quality).  Alternativelly can string name quality variable. sample.index scalar column number corresponding index group (sample). covar.index Optional. scalar numeric vector column number(s) corresponding covariate(s). Alternativelly can character vector names covariates. covar.names Optional. string vector strings names covariate columns.  valid one column data. default, takes names original object. data.name string specifying name variable appears plots. provided taken object given data. sizes Optional. value vector values specifying sample sizes associated group. continuous data, sample sizes obtained counting non-NA elements sample.index vector. attribute variable argument sizes required. center value specifying center group statistics ''target'' value process. conf.nsigma numeric value used compute control limits, specifying number standard deviations (conf.nsigma > 1) confidence level (0 < conf.nsigma < 1). limits two-values vector specifying control limits. plot Logical value. TRUE u chart plotted.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.u.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot Shewhart u chart — qcs.u","text":"","code":"data(pcmanufact) attach(pcmanufact) #> The following objects are masked from orangejuice (pos = 3): #>  #>     sample, size #> The following objects are masked from orangejuice (pos = 4): #>  #>     sample, size #> The following object is masked from pistonrings (pos = 5): #>  #>     sample #> The following object is masked from pistonrings (pos = 6): #>  #>     sample #> The following objects are masked from circuit: #>  #>     sample, size, x #> The following objects are masked from orangejuice (pos = 8): #>  #>     sample, size str(pcmanufact) #> 'data.frame':\t20 obs. of  3 variables: #>  $ x     : int  10 12 8 14 10 16 11 7 10 15 ... #>  $ sample: int  1 2 3 4 5 6 7 8 9 10 ... #>  $ size  : int  5 5 5 5 5 5 5 5 5 5 ... datos <- pcmanufact datos$sample <- 1:length(datos$x) str(datos) #> 'data.frame':\t20 obs. of  3 variables: #>  $ x     : int  10 12 8 14 10 16 11 7 10 15 ... #>  $ sample: int  1 2 3 4 5 6 7 8 9 10 ... #>  $ size  : int  5 5 5 5 5 5 5 5 5 5 ... sizes <- datos[,2]  datos.qcd <- qcd(data = datos, var.index = 1,sample.index = 2,                 sizes = sizes, type.data = \"atributte\")  res.qcs <- qcs.u(datos.qcd) summary(res.qcs) #> u chart for datos  #>  #> Summary of group statistics: #>        u           #>  Min.   : 0.2500   #>  1st Qu.: 0.5215   #>  Median : 0.8466   #>  Mean   : 1.8635   #>  3rd Qu.: 2.1667   #>  Max.   :10.0000   #>  #> Summary of group sample sizes:                                                             #>   sizes  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #>   counts 1 1 1 1 1 1 1 1 1  1  1  1  1  1  1  1  1  1  1  1 #>  #> Number of groups:  20 #> Center of group statistics:  0.9190476 #> Standard deviation:  0.9586697  #>  #> Control limits:  #>          LCL      UCL #>  0.000000000 3.795057 #>  0.000000000 2.952693 #>  0.000000000 2.579512 #>  0.000000000 2.357052 #>  0.000000000 2.205238 #>  0.000000000 2.093173 #>  0.000000000 2.006077 #>  0.000000000 1.935870 #>  0.000000000 1.877717 #>  0.009573674 1.828522 #>  0.051898236 1.786197 #>  0.088815294 1.749280 #>  0.121386202 1.716709 #>  0.150401845 1.687693 #>  0.176465252 1.661630 #>  0.200045334 1.638050 #>  0.221512945 1.616582 #>  0.241165764 1.596929 #>  0.259245872 1.578849 #>  0.275952425 1.562143 #>  #> Beyond limits of control:  #> [1] 10.000000  6.000000  2.666667  3.500000  2.666667  0.250000 #>  #> Violationg runs:  #> [1] 1.5714286 0.4705882 0.5555556 0.3684211 0.2500000 plot(res.qcs)"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.xbar.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to plot the Shewhart xbar chart — qcs.xbar","title":"Function to plot the Shewhart xbar chart — qcs.xbar","text":"function used compute statistics required xbar chart.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.xbar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to plot the Shewhart xbar chart — qcs.xbar","text":"","code":"qcs.xbar(x, ...)  # S3 method for default qcs.xbar(   x,   var.index = 1,   sample.index = 2,   covar.index = NULL,   covar.names = NULL,   data.name = NULL,   sizes = NULL,   center = NULL,   std.dev = c(\"UWAVE-R\", \"UWAVE-SD\", \"MVLUE-R\", \"MVLUE-SD\", \"RMSDF\"),   conf.nsigma = 3,   limits = NULL,   plot = FALSE,   ... )  # S3 method for qcd qcs.xbar(   x,   center = NULL,   std.dev = c(\"UWAVE-R\", \"UWAVE-SD\", \"MVLUE-R\", \"MVLUE-SD\", \"RMSDF\"),   conf.nsigma = 3,   limits = NULL,   plot = FALSE,   ... )"},{"path":"https://mflores72000.github.io/qcr/reference/qcs.xbar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to plot the Shewhart xbar chart — qcs.xbar","text":"x Object qcd (Quality Control Data). ... Arguments passed methods. var.index scalar column number corresponding observed data variable (variable quality).  Alternativelly can string name quality variable. sample.index scalar column number corresponding index group (sample). covar.index Optional. scalar numeric vector column number(s) corresponding covariate(s). Alternativelly can character vector names covariates. covar.names Optional. string vector strings names covariate columns.  valid one column data. default, takes names original object. data.name string specifying name variable appears plots. provided taken object given data. sizes Optional. value vector values specifying sample sizes associated group. continuous data, sample sizes obtained counting non-NA elements sample.index vector. attribute variable argument sizes required. center value specifying center group statistics ''target'' value process. std.dev value available method specifying within-group standard deviation(s) process. Several methods available estimating standard deviation case continuous process variable. conf.nsigma numeric value used compute control limits, specifying number standard deviations (conf.nsigma > 1) confidence level (0 < conf.nsigma < 1). limits two-value vector specifying control limits. plot Logical value. TRUE xbar chart plotted.","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.xbar.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Function to plot the Shewhart xbar chart — qcs.xbar","text":"Montgomery, D.C. (2000)","code":""},{"path":"https://mflores72000.github.io/qcr/reference/qcs.xbar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to plot the Shewhart xbar chart — qcs.xbar","text":"","code":"## ##  Continuous data  ## library(qcr) data(pistonrings) str(pistonrings) #> 'data.frame':\t200 obs. of  3 variables: #>  $ diameter: num  74 74 74 74 74 ... #>  $ sample  : int  1 1 1 1 1 2 2 2 2 2 ... #>  $ trial   : logi  TRUE TRUE TRUE TRUE TRUE TRUE ... pistonrings.qcd<-qcd(pistonrings)  class(pistonrings.qcd) #> [1] \"qcd\"        \"data.frame\"  res.qcs <- qcs.xbar(pistonrings.qcd) plot(res.qcs,title=\"Control Chart Xbar for pistonrings I\")  summary(res.qcs)   #> xbar chart for pistonrings  #>  #> Summary of group statistics: #>       xbar       #>  Min.   :73.99   #>  1st Qu.:74.00   #>  Median :74.00   #>  Mean   :74.00   #>  3rd Qu.:74.01   #>  Max.   :74.02   #>  #> Group sample size:  5 #> Number of groups:  40 #> Center of group statistics:  74.0036 #> Standard deviation:  0.01007094  #>  #> Control limits:  #>       LCL      UCL #>  73.99009 74.01712 #>  #> Beyond limits of control:  #> [1] 74.0196 74.0234 #>  #> Violationg runs:  #> [1] 74.0128  res.qcd <- state.control(res.qcs) res.qcs <- qcs.xbar(res.qcd) plot(res.qcs,title=\"Control Chart Xbar for pistonrings II\")  summary(res.qcs)   #> xbar chart for pistonrings  #>  #> Summary of group statistics: #>       xbar       #>  Min.   :73.99   #>  1st Qu.:74.00   #>  Median :74.00   #>  Mean   :74.00   #>  3rd Qu.:74.01   #>  Max.   :74.02   #>  #> Group sample size:  5 #> Number of groups:  37 #> Center of group statistics:  74.00239 #> Standard deviation:  0.009992796  #>  #> Control limits:  #>       LCL     UCL #>  73.98898 74.0158 #>  #> Beyond limits of control:  #> [1] 74.0166 #>  #> Number violationg runs: 0   res.qcd <- state.control(res.qcs) res.qcs <- qcs.xbar(res.qcd) plot(res.qcs,title=\"Control Chart Xbar for pistonrings III\")  summary(res.qcs)   #> xbar chart for pistonrings  #>  #> Summary of group statistics: #>       xbar       #>  Min.   :73.99   #>  1st Qu.:74.00   #>  Median :74.00   #>  Mean   :74.00   #>  3rd Qu.:74.01   #>  Max.   :74.01   #>  #> Group sample size:  5 #> Number of groups:  36 #> Center of group statistics:  74.00199 #> Standard deviation:  0.01004347  #>  #> Control limits:  #>       LCL      UCL #>  73.98852 74.01547 #>  #> Number beyond limits: 0  #>  #> Number violationg runs: 0   x <- droplevels(pistonrings[1:125,]) y <- droplevels(pistonrings[126:200,])  res.qcs <- qcs.xbar(x, data.name=\"Control Chart Xbar for pistonrings\") plot(res.qcs)   res.qcs <- qcs.add(x = res.qcs, value = y[,c(1,2)])  plot(res.qcs)  summary(res.qcs) #> xbar chart for Control Chart Xbar for pistonrings  #>  #> Summary of group statistics: #>       xbar       #>  Min.   :73.99   #>  1st Qu.:74.00   #>  Median :74.00   #>  Mean   :74.00   #>  3rd Qu.:74.01   #>  Max.   :74.02   #>  #> Group sample size:  5 #> Number of groups:  40 #> Center of group statistics:  74.0036 #> Standard deviation:  0.01007094  #>  #> Control limits:  #>       LCL     UCL #>  73.98805 74.0143 #>  #> Beyond limits of control:  #> [1] 74.0166 74.0196 74.0234 #>  #> Violationg runs:  #> [1] 74.0128   res.qcs <- qcs.xbar(pistonrings.qcd, std.dev=\"UWAVE-SD\") class(res.qcs) #> [1] \"qcs.xbar\" \"qcs\"      plot(res.qcs,title=\"Control Chart Xbar for pistonrings (UWAVE-SD)\")  summary(res.qcs)   #> xbar chart for pistonrings  #>  #> Summary of group statistics: #>       xbar       #>  Min.   :73.99   #>  1st Qu.:74.00   #>  Median :74.00   #>  Mean   :74.00   #>  3rd Qu.:74.01   #>  Max.   :74.02   #>  #> Group sample size:  5 #> Number of groups:  40 #> Center of group statistics:  74.0036 #> Standard deviation:  0.01003811  #>  #> Control limits:  #>       LCL      UCL #>  73.99014 74.01707 #>  #> Beyond limits of control:  #> [1] 74.0196 74.0234 #>  #> Violationg runs:  #> [1] 74.0128"},{"path":"https://mflores72000.github.io/qcr/reference/state.control.html","id":null,"dir":"Reference","previous_headings":"","what":"Univariante process state — state.control","title":"Univariante process state — state.control","text":"function removes observations sample violates  rules process control","code":""},{"path":"https://mflores72000.github.io/qcr/reference/state.control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Univariante process state — state.control","text":"","code":"state.control(x)"},{"path":"https://mflores72000.github.io/qcr/reference/state.control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Univariante process state — state.control","text":"x Object qcs (Quality Control Statistical)","code":""},{"path":"https://mflores72000.github.io/qcr/reference/state.control.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Univariante process state — state.control","text":"","code":"## ##  Continuous data  ## library(qcr) data(pistonrings) str(pistonrings) #> 'data.frame':\t200 obs. of  3 variables: #>  $ diameter: num  74 74 74 74 74 ... #>  $ sample  : int  1 1 1 1 1 2 2 2 2 2 ... #>  $ trial   : logi  TRUE TRUE TRUE TRUE TRUE TRUE ... pistonrings.qcd<-qcd(pistonrings)  class(pistonrings.qcd) #> [1] \"qcd\"        \"data.frame\"  res.qcs <- qcs.xbar(pistonrings.qcd) plot(res.qcs,title=\"Control Chart Xbar for pistonrings I\")  summary(res.qcs)   #> xbar chart for pistonrings  #>  #> Summary of group statistics: #>       xbar       #>  Min.   :73.99   #>  1st Qu.:74.00   #>  Median :74.00   #>  Mean   :74.00   #>  3rd Qu.:74.01   #>  Max.   :74.02   #>  #> Group sample size:  5 #> Number of groups:  40 #> Center of group statistics:  74.0036 #> Standard deviation:  0.01007094  #>  #> Control limits:  #>       LCL      UCL #>  73.99009 74.01712 #>  #> Beyond limits of control:  #> [1] 74.0196 74.0234 #>  #> Violationg runs:  #> [1] 74.0128  res.qcd <- state.control(res.qcs) res.qcs <- qcs.xbar(res.qcd) plot(res.qcs,title=\"Control Chart Xbar for pistonrings II\")  summary(res.qcs)   #> xbar chart for pistonrings  #>  #> Summary of group statistics: #>       xbar       #>  Min.   :73.99   #>  1st Qu.:74.00   #>  Median :74.00   #>  Mean   :74.00   #>  3rd Qu.:74.01   #>  Max.   :74.02   #>  #> Group sample size:  5 #> Number of groups:  37 #> Center of group statistics:  74.00239 #> Standard deviation:  0.009992796  #>  #> Control limits:  #>       LCL     UCL #>  73.98898 74.0158 #>  #> Beyond limits of control:  #> [1] 74.0166 #>  #> Number violationg runs: 0   res.qcd <- state.control(res.qcs) res.qcs <- qcs.xbar(res.qcd) plot(res.qcs,title=\"Control Chart Xbar for pistonrings III\")  summary(res.qcs)   #> xbar chart for pistonrings  #>  #> Summary of group statistics: #>       xbar       #>  Min.   :73.99   #>  1st Qu.:74.00   #>  Median :74.00   #>  Mean   :74.00   #>  3rd Qu.:74.01   #>  Max.   :74.01   #>  #> Group sample size:  5 #> Number of groups:  36 #> Center of group statistics:  74.00199 #> Standard deviation:  0.01004347  #>  #> Control limits:  #>       LCL      UCL #>  73.98852 74.01547 #>  #> Number beyond limits: 0  #>  #> Number violationg runs: 0"},{"path":"https://mflores72000.github.io/qcr/news/index.html","id":"qcr-14","dir":"Changelog","previous_headings":"","what":"qcr 1.4","title":"qcr 1.4","text":"CRAN release: 2022-03-02 Added website package (pkgdown). Added ‘README.md’, ‘NEWS.md’ ’_pkgdown.yml’. Added vignettes (pkgdown articles):","code":""},{"path":"https://mflores72000.github.io/qcr/news/index.html","id":"qcr-13","dir":"Changelog","previous_headings":"","what":"qcr 1.3","title":"qcr 1.3","text":"CRAN release: 2021-05-14 Avoided dependence qualityTools package removed CRAN (dependencies included internal functions ‘qualityTools.R’).","code":""},{"path":"https://mflores72000.github.io/qcr/news/index.html","id":"qcr-12","dir":"Changelog","previous_headings":"","what":"qcr 1.2","title":"qcr 1.2","text":"CRAN release: 2020-04-21 Added utilities Functional Data Quality Control: fdqcd(), fdqcs.depth(),fdqcs.rank(), plot methods plot.fdqcd(), plot.fdqcs.depth(), plot.fdqcs.rank()","code":""},{"path":"https://mflores72000.github.io/qcr/news/index.html","id":"qcr-10","dir":"Changelog","previous_headings":"","what":"qcr 1.0","title":"qcr 1.0","text":"CRAN release: 2016-07-20 Added utilities nonparametric Quality Control: npqcd(), npqcs(), npqcs.add(), npqcs.Q(), npqcs.r(), npqcs.S(), npstate.control(), plot methods plot.npqcs(), plot.npqcs.Q(), plot.npqcs.r(), plot.npqcs.S(). Added utilities parametric nonparametric Capability Analysis: qcs.ca(), qcs.cp(), qcs.cpn(), qcs.hat.cpm(), qcs.pcr().","code":""},{"path":"https://mflores72000.github.io/qcr/news/index.html","id":"qcr-01-18","dir":"Changelog","previous_headings":"","what":"qcr 0.1-18","title":"qcr 0.1-18","text":"CRAN release: 2014-05-30 Initial version package form.","code":""}]
